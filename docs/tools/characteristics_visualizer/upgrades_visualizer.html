<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>buildstock_query.tools.characteristics_visualizer.upgrades_visualizer API documentation</title>
<meta name="description" content="- - - - - - - - -
Upgrades Visualizer
Experimental Stage.
:author: Rajendra.Adhikari@nrel.gov" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buildstock_query.tools.characteristics_visualizer.upgrades_visualizer</code></h1>
</header>
<section id="section-intro">
<hr>
<p>Upgrades Visualizer
Experimental Stage.
:author: Rajendra.Adhikari@nrel.gov</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
- - - - - - - - -
Upgrades Visualizer
Experimental Stage.
:author: Rajendra.Adhikari@nrel.gov
&#34;&#34;&#34;

from functools import reduce
import re
from collections import defaultdict, Counter
import dash_bootstrap_components as dbc
from dash import html, ALL, dcc, ctx
import dash
from dash.dependencies import Input, Output, State
from dash.exceptions import PreventUpdate
from dash_extensions.enrich import MultiplexerTransform, DashProxy
import dash_mantine_components as dmc
from dash_iconify import DashIconify
from InquirerPy import inquirer
from buildstock_query.tools.upgrades_visualizer.viz_data import VizData
from buildstock_query.tools.upgrades_visualizer.plot_utils import PlotParams, ValueTypes, SavingsTypes
from buildstock_query.tools.upgrades_visualizer.figure import UpgradesPlot
import polars as pl

# os.chdir(&#34;/Users/radhikar/Documents/eulpda/EULP-data-analysis/eulpda/smart_query/&#34;)
# from: https://github.com/thedirtyfew/dash-extensions/tree/1b8c6466b5b8522690442713eb421f622a1d7a59
# app = DashProxy(transforms=[
#     # TriggerTransform(),  # enable use of Trigger objects
#     MultiplexerTransform(),  # makes it possible to target an output multiple times in callbacks
#     # ServersideOutputTransform(),  # enable use of ServersideOutput objects
#     # NoOutputTransform(),  # enable callbacks without output
#     # BlockingCallbackTransform(),  # makes it possible to skip callback invocations while a callback is running
#     # LogTransform()  # makes it possible to write log messages to a Dash component
# ])
transforms = [MultiplexerTransform()]

# yaml_path = &#34;/Users/radhikar/Documents/eulpda/EULP-data-analysis/notebooks/EUSS-project-file-example.yml&#34;
yaml_path = &#34;/Users/radhikar/Documents/largee/resstock/project_national/fact_sheets_category_1.yml&#34;
opt_sat_path = &#34;/Users/radhikar/Downloads/options_saturations.csv&#34;
default_end_use = &#34;fuel_use_electricity_total_m_btu&#34;


def filter_cols(all_columns, prefixes=[], suffixes=[]):
    cols = []
    for col in all_columns:
        for prefix in prefixes:
            if col.startswith(prefix):
                cols.append(col)
                break
        else:
            for suffix in suffixes:
                if col.endswith(suffix):
                    cols.append(col)
                    break
    return cols


def _get_app(yaml_path: str, opt_sat_path: str, db_name: str = &#39;euss-tests&#39;,
             table_name: str = &#39;res_test_03_2018_10k_20220607&#39;,
             workgroup: str = &#39;largeee&#39;,
             buildstock_type: str = &#39;resstock&#39;):
    viz_data = VizData(yaml_path=yaml_path, opt_sat_path=opt_sat_path, db_name=db_name,
                       run=table_name, workgroup=workgroup, buildstock_type=buildstock_type)
    return get_app(viz_data)


def get_app(viz_data: VizData):
    upgrades_plot = UpgradesPlot(viz_data)
    upgrade2res = viz_data.upgrade2res
    # upgrade2res_monthly = viz_data.upgrade2res_monthly
    upgrade2name = viz_data.upgrade2name
    resolution = &#39;annual&#39;
    all_cols = viz_data.upgrade2res[0].columns
    emissions_cols = filter_cols(all_cols, suffixes=[&#39;_lb&#39;])
    # end_use_cols = filter_cols(all_cols, [&#34;end_use_&#34;, &#34;energy_use__&#34;, &#34;fuel_use_&#34;])
    water_usage_cols = filter_cols(all_cols, suffixes=[&#34;_gal&#34;])
    load_cols = filter_cols(all_cols, [&#34;load_&#34;, &#34;flow_rate_&#34;])
    peak_cols = filter_cols(all_cols, [&#34;peak_&#34;])
    unmet_cols = filter_cols(all_cols, [&#34;unmet_&#34;])
    area_cols = filter_cols(all_cols, suffixes=[&#34;_ft_2&#34;, ])
    size_cols = filter_cols(all_cols, [&#34;size_&#34;])
    qoi_cols = filter_cols(all_cols, [&#34;qoi_&#34;])
    cost_cols = filter_cols(all_cols, [&#34;upgrade_cost_&#34;])
    build_cols = viz_data.metadata_df.columns
    char_cols = [c.removeprefix(viz_data.main_run.char_prefix) for c in build_cols if &#39;applicable&#39; not in c]
    char_cols += [&#39;month&#39;]
    fuels_types = [&#39;electricity&#39;, &#39;natural_gas&#39;, &#39;propane&#39;, &#39;fuel_oil&#39;, &#39;coal&#39;, &#39;wood_cord&#39;, &#39;wood_pellets&#39;]
    change_types = [&#34;any&#34;, &#34;no-chng&#34;, &#34;bad-chng&#34;, &#34;ok-chng&#34;, &#34;true-bad-chng&#34;, &#34;true-ok-chng&#34;]
    download_csv_df = pl.DataFrame()

    def get_buildings(upgrade):
        return upgrade2res[int(upgrade)][&#39;building_id&#39;].to_list()

    def get_plot(end_use, value_type=&#39;mean&#39;, savings_type=&#39;&#39;, change_type=&#39;&#39;,
                 sync_upgrade=None, filter_bldg=None, group_cols=None, report_upgrade=None):
        filter_bldg = filter_bldg or []
        group_cols = group_cols or []
        sync_upgrade = sync_upgrade or 0
        report_upgrade = int(report_upgrade) if report_upgrade else None

        params = PlotParams(enduses=end_use, value_type=ValueTypes[value_type.lower()],
                            savings_type=SavingsTypes[savings_type.lower().replace(&#39; &#39;, &#39;_&#39;)],
                            change_type=change_type, sync_upgrade=sync_upgrade,
                            filter_bldgs=filter_bldg, group_by=group_cols, upgrade=report_upgrade,
                            resolution=resolution)
        return upgrades_plot.get_plot(params)

    external_script = [&#34;https://tailwindcss.com/&#34;, {&#34;src&#34;: &#34;https://cdn.tailwindcss.com&#34;}]

    app = DashProxy(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], transforms=transforms,
                    external_scripts=external_script)
    app.layout = html.Div([dbc.Container(html.Div([
        dcc.Download(id=&#34;download-dataframe-csv&#34;),
        dbc.Row([dbc.Col(html.H1(&#34;Upgrades Visualizer&#34;), width=&#39;auto&#39;), dbc.Col(html.Sup(&#34;beta&#34;))]),
        # Add a row for annual, vs monthly vs seasonal plot radio buttons
        dbc.Row([dbc.Col(dbc.Label(&#34;Resolution: &#34;), width=&#39;auto&#39;),
                 dbc.Col(dcc.RadioItems([&#34;annual&#34;, &#34;monthly&#34;], &#34;annual&#34;,
                                        inline=True, id=&#34;radio_resolution&#34;))]),

        dbc.Row([dbc.Col(dbc.Label(&#34;Visualization Type: &#34;), width=&#39;auto&#39;),
                 dbc.Col(dcc.RadioItems([&#34;Mean&#34;, &#34;Total&#34;, &#34;Count&#34;, &#34;Distribution&#34;, &#34;Scatter&#34;], &#34;Mean&#34;,
                                        id=&#34;radio_graph_type&#34;,
                                        inline=True,
                                        labelClassName=&#34;pr-2&#34;), width=&#39;auto&#39;),
                 dbc.Col(dbc.Label(&#34;Value Type: &#34;), width=&#39;auto&#39;),
                 dbc.Col(dcc.RadioItems([&#34;Absolute&#34;, &#34;Savings&#34;, &#34;Percent Savings&#34;], &#34;Absolute&#34;,  inline=True,
                                        id=&#39;radio_savings&#39;, labelClassName=&#34;pr-2&#34;), width=&#39;auto&#39;),
                 ]),
        dbc.Row([dbc.Col(html.Br())]),
        dbc.Row([dbc.Col(dcc.Loading(id=&#39;graph-loader&#39;, children=[html.Div(id=&#39;loader_label&#39;)]))]),
        dbc.Row([dbc.Col(dcc.Graph(id=&#39;graph&#39;))]),
        dbc.Row([dbc.Col(dbc.Button(&#34;Download&#34;, id=&#39;csv-download&#39;))], justify=&#39;end&#39;),
        dcc.Store(id=&#39;graph-data-store&#39;),
    ])),
        dbc.Row([dbc.Col(
            dcc.Tabs(id=&#39;tab_view_type&#39;, value=&#39;energy&#39;, children=[
                dcc.Tab(id=&#39;energy_tab&#39;, label=&#39;Energy&#39;, value=&#39;energy&#39;, children=[
                    dcc.RadioItems(fuels_types + [&#39;All&#39;], &#34;electricity&#34;, id=&#39;radio_fuel&#39;,  inline=True,
                                   labelClassName=&#34;pr-2&#34;)]
                        ),
                dcc.Tab(label=&#39;Water Usage&#39;, value=&#39;water&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Load&#39;, value=&#39;load&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Peak&#39;, value=&#39;peak&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Unmet Hours&#39;, value=&#39;unmet_hours&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Area&#39;, value=&#39;area&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Size&#39;, value=&#39;size&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;QOI&#39;, value=&#39;qoi&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;emissions&#39;, value=&#39;emissions&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Upgrade Cost&#39;, value=&#39;upgrade_cost&#39;, children=[]
                        ),
            ])
        )
        ], className=&#34;mx-5 mt-5&#34;),
        dbc.Row([dbc.Col(dcc.Dropdown(id=&#39;dropdown_enduse&#39;))], className=&#34;mx-5 my-1&#34;),
        dbc.Row(
            dbc.Col([
                dbc.Row([dbc.Col(html.Div(&#34;Restrict to buildings that have &#34;), width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(change_types, &#34;&#34;, placeholder=&#34;Select change type...&#34;,
                                              id=&#39;dropdown_chng_type&#39;), width=&#39;2&#39;),
                         dbc.Col(html.Div(&#34; in &#34;), width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;sync_upgrade&#39;, value=&#39;&#39;,
                                              options={}))
                         ],
                        className=&#34;flex items-center&#34;),
                dbc.Row([dbc.Col(html.Div(&#34;Select:&#34;), style={&#34;padding-left&#34;: &#34;12px&#34;, &#34;padding-right&#34;: &#34;0px&#34;},
                                 width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;input_building&#39;), width=1),
                         dbc.Col(html.Div(&#34;(&#34;), width=&#39;auto&#39;,
                                 style={&#34;padding-left&#34;: &#34;0px&#34;, &#34;padding-right&#34;: &#34;0px&#34;}),
                         dbc.Col(dcc.Checklist([&#39;Lock)&#39;], [],
                                               inline=True, id=&#39;chk-lock&#39;),
                                 width=&#39;auto&#39;, style={&#34;padding-left&#34;: &#34;0px&#34;, &#34;padding-right&#34;: &#34;0px&#34;}),
                         dbc.Col(html.Div(&#34; in &#34;), style={&#34;padding-right&#34;: &#34;0px&#34;}, width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;report_upgrade&#39;, value=&#39;&#39;, placeholder=&#34;Upgrade ...&#34;,
                                              options=viz_data.upgrade2shortname), width=1),
                         dbc.Col(html.Div(&#34;grouped by:&#34;), style={&#34;padding-right&#34;: &#34;0px&#34;}, width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;drp-group-by&#39;, options=char_cols, value=None,
                                              multi=True, placeholder=&#34;Select characteristics...&#34;),
                                 width=3),
                         dbc.Col(dbc.Button(&#34;&lt;= Copy&#34;, id=&#34;btn-copy&#34;, color=&#34;primary&#34;, size=&#34;sm&#34;,
                                            outline=True), class_name=&#34;centered-col&#34;, style={&#34;padding-right&#34;: &#34;0px&#34;}),
                         dbc.Col(html.Div(&#34;Extra restriction: &#34;), style={&#34;padding-right&#34;: &#34;0px&#34;}, width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;input_building2&#39;, disabled=False), width=1),
                         dbc.Col(dcc.Checklist(id=&#39;chk-graph&#39;, options=[&#39;Graph&#39;], value=[],
                                               inline=True), width=&#39;auto&#39;),
                         dbc.Col(dcc.Checklist(id=&#39;chk-options&#39;, options=[&#39;Options&#39;], value=[],
                                               inline=True), width=&#39;auto&#39;),
                         dbc.Col(dcc.Checklist(id=&#39;chk-enduses&#39;, options=[&#39;Enduses&#39;], value=[],
                                               inline=True), width=&#39;auto&#39;),
                         dbc.Col(dcc.Checklist(id=&#39;chk-chars&#39;, options=[&#39;Chars&#39;], value=[],
                                               inline=True), width=&#39;auto&#39;),
                         dbc.Col(dbc.Button(&#34;Reset&#34;, id=&#34;btn-reset&#34;, color=&#34;primary&#34;, size=&#34;sm&#34;, outline=True),
                                 width=&#39;auto&#39;),
                         ]),
                dbc.Row([dbc.Col([
                    dbc.Row(html.Div(id=&#34;options_report_header&#34;)),
                    dbc.Row(dcc.Loading(id=&#39;opt-loader&#39;,
                                        children=html.Div(id=&#34;options_report&#34;))),
                    dcc.Store(&#34;opt_report_store&#34;)
                ], width=5),
                    dbc.Col([
                        dbc.Row([dbc.Col(html.Div(&#34;View enduse that: &#34;), width=&#39;auto&#39;),
                                 dbc.Col(dcc.Dropdown(id=&#39;input_enduse_type&#39;,
                                                      options=[&#39;changed&#39;, &#39;increased&#39;, &#39;decreased&#39;, &#39;are almost zero&#39;],
                                                      value=&#39;changed&#39;, clearable=False),
                                         width=2),
                                 dbc.Col(html.Div(), width=&#39;auto&#39;),
                                 dbc.Col(html.Div(&#34;Charecteristics Report:&#34;), width=&#39;auto&#39;),
                                 dbc.Col(dcc.Dropdown(id=&#39;drp-char-report&#39;, options=char_cols, value=None,
                                                      multi=True, placeholder=&#34;Select characteristics...&#34;)),
                                 ]),
                        dbc.Row([dbc.Col(dcc.Loading(id=&#39;enduse_loader&#39;,
                                                     children=html.Div(id=&#34;enduse_report&#34;))
                                         ),
                                 dbc.Col(dcc.Loading(id=&#39;char_loader&#39;,
                                                     children=html.Div(id=&#34;char_report&#34;))
                                         ),
                                 ]),
                        dcc.Store(&#34;enduse_report_store&#34;),
                        dcc.Store(&#34;char_report_store&#34;)
                    ], width=7)

                ]),
                dbc.Row([
                    dbc.Col(width=5),
                    dbc.Col(
                        dbc.Row([
                            dbc.Col(),
                            dbc.Col(dbc.Button(&#34;Download All Characteristics&#34;, id=&#34;btn-dwn-chars&#34;,
                                               color=&#34;primary&#34;,
                                               size=&#34;sm&#34;, outline=True), width=&#39;auto&#39;),
                        ]), width=7)
                ])
            ]), className=&#34;mx-5 my-1&#34;),
        html.Div(id=&#34;status_bar&#34;),
        dcc.Download(id=&#34;download-chars-csv&#34;),
        dcc.Store(&#34;uirevision&#34;)
        # dbc.Button(&#34;Kill me&#34;, id=&#34;button110&#34;)
    ])

    # download data with button click
    @app.callback(
        Output(&#34;download-dataframe-csv&#34;, &#34;data&#34;),
        Input(&#34;csv-download&#34;, &#34;n_clicks&#34;),
        prevent_initial_call=True)
    def download_csv(n_clicks):
        if not n_clicks:
            raise PreventUpdate()
        nonlocal download_csv_df
        return dcc.send_bytes(download_csv_df.write_csv, &#34;graph_data.csv&#34;)

    @app.callback(
        Output(&#34;download-chars-csv&#34;, &#34;data&#34;),
        Input(&#34;btn-dwn-chars&#34;, &#34;n_clicks&#34;),
        State(&#34;input_building&#34;, &#34;value&#34;),
        State(&#34;input_building&#34;, &#34;options&#34;),
        State(&#34;input_building2&#34;, &#34;options&#34;),
        State(&#39;chk-chars&#39;, &#39;value&#39;),
    )
    def download_char(n_clicks, bldg_id, bldg_options, bldg_options2, chk_chars):
        if not n_clicks:
            raise PreventUpdate()

        if &#34;Chars&#34; in chk_chars and bldg_options2:
            bldg_ids = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options2]
        else:
            bldg_ids = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options]
        bldg_ids = [int(b) for b in bldg_ids]
        bdf = viz_data.upgrade2res[0].filter(pl.col(&#34;building_id&#34;).is_in(set(bldg_ids))).select(char_cols)
        return dcc.send_bytes(bdf.write_csv, f&#34;chars_{n_clicks}.csv&#34;)

    def get_elligible_output_columns(category, fuel):
        if category == &#39;energy&#39;:
            elligible_cols = viz_data.get_cleaned_up_end_use_cols(resolution, fuel)
        elif category == &#39;water&#39;:
            elligible_cols = water_usage_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;load&#39;:
            elligible_cols = load_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;peak&#39;:
            elligible_cols = peak_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;unmet_hours&#39;:
            elligible_cols = unmet_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;area&#39;:
            elligible_cols = area_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;size&#39;:
            elligible_cols = size_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;qoi&#39;:
            elligible_cols = qoi_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;emissions&#39;:
            elligible_cols = emissions_cols if resolution == &#39;annual&#39; else\
                             viz_data.get_emissions_cols(resolution=resolution)
        elif category == &#39;upgrade_cost&#39;:
            elligible_cols = cost_cols if resolution == &#39;annual&#39; else []
        else:
            raise ValueError(f&#34;Invalid tab {category}&#34;)
        return elligible_cols

    @app.callback(
            Output(&#39;radio_resolution&#39;, &#39;options&#39;),
            Input(&#39;radio_resolution&#39;, &#39;value&#39;),
    )
    def update_resolution(res):
        nonlocal resolution
        resolution = res
        return [&#39;annual&#39;, &#39;monthly&#39;]

    @app.callback(
        Output(&#39;dropdown_enduse&#39;, &#34;options&#34;),
        Output(&#39;dropdown_enduse&#39;, &#34;value&#34;),
        Input(&#39;tab_view_type&#39;, &#34;value&#34;),
        Input(&#39;radio_fuel&#39;, &#34;value&#34;),
        Input(&#39;dropdown_enduse&#39;, &#34;value&#34;),
        Input(&#39;radio_resolution&#39;, &#39;value&#39;)
    )
    def update_enduse_options(view_tab, fuel_type, current_enduse, resolution):
        elligible_cols = get_elligible_output_columns(view_tab, fuel_type)
        enduse = current_enduse if current_enduse in elligible_cols else elligible_cols[0]
        return sorted(elligible_cols), enduse

    @app.callback(
        Output(&#34;sync_upgrade&#34;, &#39;value&#39;),
        Output(&#34;sync_upgrade&#34;, &#39;options&#39;),
        Output(&#34;sync_upgrade&#34;, &#39;placeholder&#39;),
        Input(&#39;dropdown_chng_type&#39;, &#34;value&#34;),
        State(&#34;sync_upgrade&#34;, &#34;value&#34;),
        State(&#34;sync_upgrade&#34;, &#34;options&#34;)
    )
    def update_sync_upgrade(chng_type, current_sync_upgrade, sync_upgrade_options):
        # print(chng_type, current_sync_upgrade, sync_upgrade_options)
        if chng_type:
            return current_sync_upgrade, upgrade2name, &#39;respective upgrades. (Click to restrict to specific upgrade)&#39;
        else:
            return &#39;&#39;, {}, &#39; &lt;select a change type on the left first&gt;&#39;

    @app.callback(
        Output(&#39;input_building&#39;, &#39;placeholder&#39;),
        Input(&#39;input_building&#39;, &#39;options&#39;)
    )
    def update_building_placeholder(options):
        return f&#34;{len(options)} Buidlings&#34; if options else &#34;0 buildings.&#34;

    @app.callback(
        Output(&#39;input_building2&#39;, &#39;placeholder&#39;),
        Output(&#39;input_building2&#39;, &#39;value&#39;),
        Input(&#39;input_building2&#39;, &#39;value&#39;),
        Input(&#39;input_building2&#39;, &#39;options&#39;)
    )
    def update_building_placeholder2(value, options):
        return f&#34;{len(options)} Buidlings&#34; if options else &#34;No restriction&#34;, None

    @app.callback(
        Output(&#39;input_building&#39;, &#39;value&#39;),
        Output(&#39;input_building&#39;, &#39;options&#39;),
        Output(&#39;report_upgrade&#39;, &#39;value&#39;),
        Input(&#39;graph&#39;, &#34;selectedData&#34;),
        State(&#39;input_building&#39;, &#39;options&#39;),
        State(&#39;report_upgrade&#39;, &#39;value&#39;)
    )
    def graph_click(selection_data, current_options, current_upgrade):
        if not selection_data or &#39;points&#39; not in selection_data or len(selection_data[&#39;points&#39;]) &lt; 1:
            raise PreventUpdate()

        selected_buildings = []
        selected_upgrades = []
        for point in selection_data[&#39;points&#39;]:
            if not (match := re.search(r&#34;Building: (\d*)&#34;, point.get(&#39;hovertext&#39;, &#39;&#39;))):
                continue
            if bldg := match.groups()[0]:
                upgrade_match = re.search(r&#34;Upgrade (\d*)&#34;, point.get(&#39;hovertext&#39;, &#39;&#39;))
                upgrade = upgrade_match.groups()[0] if upgrade_match else &#39;&#39;
                selected_buildings.append(bldg)
                selected_upgrades.append(upgrade)

        if not selected_buildings:
            raise PreventUpdate()

        selected_upgrade = selected_upgrades[0] or current_upgrade
        if len(selected_buildings) != 1:
            selected_buildings = list(set(selected_buildings))
            return &#39;&#39;, selected_buildings, selected_upgrade
        current_options = current_options or selected_buildings
        return selected_buildings[0], current_options, selected_upgrade

    @app.callback(
        Output(&#39;chk-graph&#39;, &#39;value&#39;),
        Output(&#39;chk-options&#39;, &#39;value&#39;),
        Output(&#39;chk-enduses&#39;, &#39;value&#39;),
        Output(&#39;input_building2&#39;, &#39;options&#39;),
        Output(&#34;uirevision&#34;, &#34;data&#34;),
        Input(&#39;btn-reset&#39;, &#34;n_clicks&#34;)
    )
    def reset(n_clicks):
        return [], [], [], [], n_clicks

    @app.callback(
        Output(&#39;input_building&#39;, &#39;options&#39;),
        Input(&#39;btn-copy&#39;, &#34;n_clicks&#34;),
        State(&#39;input_building2&#39;, &#39;options&#39;),
    )
    def copy(n_clicks, bldg_options2):
        return bldg_options2 or dash.no_update

    @app.callback(
        Output(&#39;input_building&#39;, &#39;value&#39;),
        Output(&#39;input_building&#39;, &#39;options&#39;),
        Output(&#39;input_building2&#39;, &#39;options&#39;),
        State(&#39;input_building&#39;, &#39;value&#39;),
        State(&#39;input_building&#39;, &#39;options&#39;),
        State(&#39;input_building2&#39;, &#39;options&#39;),
        Input(&#39;chk-lock&#39;, &#39;value&#39;),
        Input(&#39;dropdown_chng_type&#39;, &#34;value&#34;),
        Input(&#39;sync_upgrade&#39;, &#39;value&#39;),
        Input(&#39;report_upgrade&#39;, &#39;value&#39;),
        Input(&#39;btn-reset&#39;, &#34;n_clicks&#34;)
    )
    def bldg_selection(current_bldg, current_options, current_options2, chk_lock,
                       change_type, sync_upgrade, report_upgrade,
                       reset_click):

        if sync_upgrade and change_type:
            valid_bldgs = set(viz_data.chng2bldg[(int(sync_upgrade), change_type)])
        elif report_upgrade and change_type:
            valid_bldgs = set(viz_data.chng2bldg[(int(report_upgrade), change_type)])
            buildings = get_buildings(report_upgrade)
            valid_bldgs = set(buildings).intersection(valid_bldgs)
        elif report_upgrade:
            buildings = get_buildings(report_upgrade)
            valid_bldgs = set(buildings)
        else:
            valid_bldgs = set(viz_data.upgrade2res[0][&#39;building_id&#39;].to_list())

        base_res = upgrade2res[0].filter(pl.col(&#34;building_id&#34;).is_in(valid_bldgs))
        valid_bldgs = list(base_res[&#39;building_id&#39;].to_list())

        if &#34;btn-reset&#34; != ctx.triggered_id and current_options and len(current_options) &gt; 0 and chk_lock:
            current_options_set = set(current_options)
            valid_bldgs = [b for b in valid_bldgs if b in current_options_set]

        valid_bldgs2 = []

        if current_bldg and (int(current_bldg) not in valid_bldgs):
            current_bldg = valid_bldgs[0] if valid_bldgs else &#39;&#39;
        return current_bldg, valid_bldgs, valid_bldgs2

    def get_char_choices(char):
        if char:
            res0 = upgrade2res[0]
            unique_choices = sorted(list(res0[char].unique()))
            return unique_choices, unique_choices[0]
        else:
            return [], None

    def get_action_button_pairs(id, bldg_list_dict, report_type=&#39;opt&#39;):
        buttons = []
        bldg_str = &#39;&#39; if len(bldg_list_dict[id]) &gt; 10 else &#34; [&#34; + &#39;,&#39;.join([str(b) for b in bldg_list_dict[id]]) + &#34;]&#34;
        for type in [&#39;check&#39;, &#39;cross&#39;]:
            icon_name = &#34;akar-icons:circle-check-fill&#34; if type == &#39;check&#39; else &#34;gridicons:cross-circle&#34;
            button = html.Div(dmc.ActionIcon(DashIconify(icon=icon_name,
                                                         width=20 if type == &#34;check&#34; else 22,
                                                         height=20 if type == &#34;check&#34; else 22,
                                                         ),
                                             id={&#39;index&#39;: id, &#39;type&#39;: f&#39;btn-{type}&#39;, &#39;report_type&#39;: report_type},
                                             variant=&#34;light&#34;),
                              id=f&#34;div-tooltip-target-{type}-{id}&#34;)
            if type == &#34;check&#34;:
                tooltip = dbc.Tooltip(f&#34;Select these buildings.{bldg_str}&#34;,
                                      target=f&#34;div-tooltip-target-{type}-{id}&#34;, delay={&#39;show&#39;: 1000})

                col = dbc.Col(html.Div([button, tooltip]),  width=&#39;auto&#39;, class_name=&#34;col-btn-cross&#34;,
                              style={&#34;padding-left&#34;: &#34;0px&#34;, &#34;padding-right&#34;: &#34;0px&#34;})
            else:
                tooltip = dbc.Tooltip(f&#34;Select all except these buildings.{bldg_str}&#34;,
                                      target=f&#34;div-tooltip-target-{type}-{id}&#34;, delay={&#39;show&#39;: 1000})
                col = dbc.Col(html.Div([button, tooltip]),  width=&#39;auto&#39;,  class_name=&#34;col-btn-check&#34;,
                              style={&#34;padding-left&#34;: &#34;0px&#34;, &#34;padding-right&#34;: &#34;0px&#34;})
            buttons.append(col)
        return buttons

    @app.callback(
        Output(&#39;status_bar&#39;, &#34;children&#34;),
        Output(&#39;input_building2&#39;, &#34;options&#34;),
        Input({&#34;type&#34;: &#34;btn-check&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;opt&#34;}, &#34;n_clicks&#34;),
        Input({&#34;type&#34;: &#34;btn-cross&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;opt&#34;}, &#34;n_clicks&#34;),
        State(&#34;input_building&#34;, &#34;options&#34;),
        State(&#34;input_building2&#34;, &#34;options&#34;),
        State(&#34;chk-options&#34;, &#34;value&#34;),
        State(&#34;opt_report_store&#34;, &#34;data&#34;),
    )
    def opt_check_button_click(check_clicks, cross_clicks, bldg_options, bldg_options2, chk_options, opt_report):
        triggers = dash.callback_context.triggered_prop_ids
        if len(triggers) != 1:
            raise PreventUpdate()

        if &#34;Options&#34; in chk_options and bldg_options2:
            bldg_list = [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(b) for b in bldg_options]

        trigger_val = next(iter(triggers.values()))
        buildings = opt_report.get(trigger_val[&#39;index&#39;], [])
        if trigger_val[&#39;type&#39;] == &#39;btn-check&#39;:
            return &#39;&#39;, [str(b) for b in buildings]

        bldg_set = set(buildings)
        except_buildings = [str(v) for v in bldg_list if int(v) not in bldg_set]
        return &#39;&#39;, except_buildings

    @app.callback(
        Output(&#39;status_bar&#39;, &#34;children&#34;),
        Output(&#39;input_building2&#39;, &#34;options&#34;),
        Input({&#34;type&#34;: &#34;btn-check&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;enduse&#34;}, &#34;n_clicks&#34;),
        Input({&#34;type&#34;: &#34;btn-cross&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;enduse&#34;}, &#34;n_clicks&#34;),
        State(&#34;input_building&#34;, &#34;options&#34;),
        State(&#34;input_building2&#34;, &#34;options&#34;),
        State(&#34;chk-enduses&#34;, &#34;value&#34;),
        State(&#34;enduse_report_store&#34;, &#34;data&#34;),
    )
    def enduse_button_click(check_clicks, cross_clicks, bldg_options, bldg_options2, chk_enduses, opt_report):
        triggers = dash.callback_context.triggered_prop_ids
        if len(triggers) != 1:
            raise PreventUpdate()

        if &#34;Enduses&#34; in chk_enduses and bldg_options2:
            bldg_list = [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(b) for b in bldg_options]

        trigger_val = next(iter(triggers.values()))
        buildings = opt_report.get(trigger_val[&#39;index&#39;], [])
        if trigger_val[&#39;type&#39;] == &#39;btn-check&#39;:
            return &#39;&#39;, [str(b) for b in buildings]

        bldg_set = set(buildings)
        except_buildings = [str(v) for v in bldg_list if int(v) not in bldg_set]
        return &#39;&#39;, except_buildings

    @app.callback(
        Output(&#39;status_bar&#39;, &#34;children&#34;),
        Output(&#39;input_building2&#39;, &#34;options&#34;),
        Input({&#34;type&#34;: &#34;btn-check&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;char&#34;}, &#34;n_clicks&#34;),
        Input({&#34;type&#34;: &#34;btn-cross&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;char&#34;}, &#34;n_clicks&#34;),
        State(&#34;input_building&#34;, &#34;options&#34;),
        State(&#34;input_building2&#34;, &#34;options&#34;),
        State(&#39;chk-chars&#39;, &#39;value&#39;),
        State(&#34;char_report_store&#34;, &#34;data&#34;),
    )
    def char_report_button_click(check_clicks, cross_clicks, bldg_options, bldg_options2, chk_char, char_report):
        triggers = dash.callback_context.triggered_prop_ids
        if len(triggers) != 1:
            raise PreventUpdate()

        if &#34;Chars&#34; in chk_char and bldg_options2:
            bldg_list = [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(b) for b in bldg_options]

        trigger_val = next(iter(triggers.values()))
        buildings = char_report.get(trigger_val[&#39;index&#39;], [])
        if trigger_val[&#39;type&#39;] == &#39;btn-check&#39;:
            return &#39;&#39;, [str(b) for b in buildings]

        bldg_set = set(buildings)
        except_buildings = [str(v) for v in bldg_list if int(v) not in bldg_set]
        return &#39;&#39;, except_buildings

    @app.callback(
        Output(&#34;options_report_header&#34;, &#34;children&#34;),
        Output(&#34;options_report&#34;, &#39;children&#39;),
        Output(&#34;opt_report_store&#34;, &#34;data&#34;),
        Input(&#39;input_building&#39;, &#34;value&#34;),
        Input(&#39;input_building&#39;, &#34;options&#34;),
        Input(&#39;input_building2&#39;, &#34;options&#34;),
        State(&#39;report_upgrade&#39;, &#39;value&#39;),
        Input(&#39;chk-options&#39;, &#39;value&#39;),
    )
    def show_opt_report(bldg_id, bldg_options, bldg_options2, report_upgrade, chk_options):
        if not report_upgrade or not bldg_options:
            return &#34;Select an upgrade to see options applied in that upgrade&#34;, [&#39;&#39;], {}

        if dash.callback_context.triggered_id == &#39;input_building2&#39; and &#34;Options&#34; not in chk_options:
            raise PreventUpdate()

        if &#34;Options&#34; in chk_options and bldg_options2:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options]
        run_obj = viz_data.run_obj(int(report_upgrade))
        applied_options = run_obj.report.get_applied_options(upgrade_id=int(report_upgrade),
                                                             bldg_ids=bldg_list,
                                                             include_base_opt=True)
        opt_only = [{entry.split(&#39;|&#39;)[0] for entry in opt.keys()} for opt in applied_options]
        reduced_set = list(reduce(set.union, opt_only))

        nested_dict = defaultdict(lambda: defaultdict(Counter))
        bldg_list_dict = defaultdict(list)

        for bldg_id, opt_dict in zip(bldg_list, applied_options):
            for opt_para, value in opt_dict.items():
                opt = opt_para.split(&#39;|&#39;)[0]
                para = opt_para.split(&#39;|&#39;)[1]
                nested_dict[opt][para][value] += 1
                bldg_list_dict[opt].append(bldg_id)
                bldg_list_dict[opt + &#34;|&#34; + para].append(bldg_id)
                bldg_list_dict[opt + &#34;|&#34; + para + &#34;&lt;-&#34; + value].append(bldg_id)

        def get_accord_item(opt_name):
            total_count = sum(counter.total() for counter in nested_dict[opt_name].values())
            children = []
            for parameter, counter in nested_dict[opt_name].items():
                contents = []
                new_counter = Counter({&#34;All&#34;: counter.total()})
                new_counter.update(counter)
                for from_val, count in new_counter.items():
                    if from_val == &#34;All&#34;:
                        but_ids = f&#34;{opt_name}|{parameter}&#34;
                    else:
                        but_ids = f&#34;{opt_name}|{parameter}&lt;-{from_val}&#34;
                    entry = dbc.Row([dbc.Col(f&#34;&lt;-{from_val} ({count})&#34;, width=&#34;auto&#34;),
                                     *get_action_button_pairs(but_ids, bldg_list_dict)])
                    contents.append(entry)
                children.append(dmc.AccordionItem(contents, label=f&#34;{parameter} ({counter.total()})&#34;))

            accordian = dmc.Accordion(children, multiple=True)
            first_row = dbc.Row([dbc.Col(f&#34;All ({total_count})&#34;, width=&#34;auto&#34;),
                                 *get_action_button_pairs(opt_name, bldg_list_dict)])
            return dmc.AccordionItem([first_row, accordian], label=f&#34;{opt_name} ({total_count})&#34;)
        if reduced_set:
            final_report = dmc.Accordion([get_accord_item(opt_name) for opt_name in reduced_set], multiple=True)
        else:
            final_report = [&#34;No option got applied to the selected building(s).&#34;]
        up_name = upgrade2name[int(report_upgrade)]
        return f&#34;Options applied in {up_name}&#34;, final_report, dict(bldg_list_dict)

    @app.callback(
        Output(&#34;enduse_report&#34;, &#34;children&#34;),
        Output(&#34;enduse_report_store&#34;, &#34;data&#34;),
        State(&#39;report_upgrade&#39;, &#39;value&#39;),
        Input(&#39;input_building&#39;, &#34;value&#34;),
        Input(&#39;input_building&#39;, &#34;options&#34;),
        Input(&#39;input_building2&#39;, &#34;options&#34;),
        Input(&#39;input_enduse_type&#39;, &#39;value&#39;),
        Input(&#39;chk-enduses&#39;, &#39;value&#39;),
    )
    def show_enduse_report(report_upgrade, bldg_id, bldg_options, bldg_options2, enduse_change_type, chk_enduse):
        if not report_upgrade or not bldg_options:
            return [&#34;Select an upgrade to see enuse report.&#34;], {}

        if dash.callback_context.triggered_id == &#39;input_building2&#39; and &#34;Enduses&#34; not in chk_enduse:
            raise PreventUpdate()

        if &#34;Enduses&#34; in chk_enduse and bldg_options2:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options]

        # print(bldg_list)
        run_obj = viz_data.run_obj(int(report_upgrade))
        dict_changed_enduses = run_obj.report.get_enduses_buildings_map_by_change(upgrade_id=int(report_upgrade),
                                                                                  change_type=enduse_change_type,
                                                                                  bldg_list=bldg_list)
        # print(changed_enduses)

        all_changed_enduses = list(dict_changed_enduses.keys())
        if not all_changed_enduses:
            if bldg_id:
                return f&#39;No enduse has {enduse_change_type} in building {bldg_id} &#39;, {}
            else:
                return f&#39;No enduse has {enduse_change_type} in any of the buildings&#39;, {}

        enduses2bldgs = defaultdict(list)
        for end_use, bldgs in dict_changed_enduses.items():
            if end_use in all_changed_enduses:
                enduses2bldgs[end_use].extend([int(bldg_id) for bldg_id in bldgs])

        fuel2bldgs = defaultdict(set)
        fuel2enduses = defaultdict(list)
        for enduse, bldgs in enduses2bldgs.items():
            for fuel in [&#39;all_fuel&#39;] + fuels_types:
                if fuel in enduse:
                    fuel2bldgs[fuel] |= set(bldgs)
                    fuel2enduses[fuel].append(enduse)
                    break
            else:
                fuel2bldgs[&#39;other&#39;] |= set(bldgs)
                fuel2enduses[&#39;other&#39;].append(enduse)

        for key, val in fuel2bldgs.items():
            fuel2bldgs[key] = list(val)

        enduses2bldgs.update(fuel2bldgs)

        def get_accord_item(fuel):
            total_count = len(enduses2bldgs[fuel])
            contents = [dbc.Row([dbc.Col(f&#34;All {fuel} ({total_count})&#34;, width=&#34;auto&#34;),
                                 *get_action_button_pairs(fuel, enduses2bldgs, &#34;enduse&#34;)])]
            for enduse in fuel2enduses[fuel]:
                count = len(enduses2bldgs[enduse])
                row = dbc.Row([dbc.Col(f&#34;{enduse} ({count})&#34;, width=&#34;auto&#34;),
                               *get_action_button_pairs(enduse, enduses2bldgs, &#34;enduse&#34;)])
                contents.append(row)
            return dmc.AccordionItem(contents, label=f&#34;{fuel} ({total_count})&#34;)

        report = dmc.Accordion([get_accord_item(fuel) for fuel in fuel2enduses.keys()],  multiple=True)
        storedict = dict(enduses2bldgs)
        return report, storedict

    @app.callback(
        Output(&#34;char_report&#34;, &#34;children&#34;),
        Output(&#34;char_report_store&#34;, &#34;data&#34;),
        Input(&#39;input_building&#39;, &#34;value&#34;),
        Input(&#39;input_building&#39;, &#34;options&#34;),
        Input(&#39;input_building2&#39;, &#34;options&#34;),
        Input(&#39;drp-char-report&#39;, &#39;value&#39;),
        Input(&#39;chk-chars&#39;, &#39;value&#39;),
    )
    def show_char_report(bldg_id, bldg_options, bldg_options2, inp_char: list[str], chk_chars):
        if not (bldg_options or bldg_options2 or bldg_id):
            return [&#34;&#34;], {}
        if not inp_char:
            return [&#34;Select a characteristics to see its report.&#34;], {}

        if dash.callback_context.triggered_id == &#39;input_building2&#39; and &#34;Chars&#34; not in chk_chars:
            raise PreventUpdate()

        if &#34;Chars&#34; in chk_chars and bldg_options2:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options]
        chars_df = viz_data.bs_res_df.filter(pl.col(&#39;building_id&#39;).is_in(
                    set(bldg_list))).select(inp_char + [&#39;building_id&#39;])
        char2bldgs = chars_df.groupby(inp_char).agg(&#39;building_id&#39;)
        if (total_len := len(char2bldgs)) &gt; 250:
            return [f&#34;Sorry, this would create more than 200 ({total_len}) rows.&#34;], {}
        char_dict = {}
        total_count = 0
        contents = []
        for char_vals, group_df in chars_df.groupby(inp_char):
            bldglist = group_df[&#39;building_id&#39;].to_list()
            but_ids = &#34;+&#34;.join(char_vals) if isinstance(char_vals, tuple) else char_vals
            char_dict[but_ids] = [int(b) for b in bldglist]
            count = len(bldglist)
            total_count += count
            contents.append(dbc.Row([dbc.Col(f&#34;{char_vals} ({count})&#34;, width=&#34;auto&#34;),
                                     *get_action_button_pairs(but_ids, char_dict, &#34;char&#34;)]))

        report = dmc.Accordion([dmc.AccordionItem(contents, label=f&#34;{inp_char} ({total_count})&#34;)])
        return report, char_dict

    @app.callback(
        Output(&#39;graph&#39;, &#39;figure&#39;),
        Output(&#39;graph&#39;, &#39;config&#39;),
        Output(&#39;loader_label&#39;, &#34;children&#34;),
        State(&#39;tab_view_type&#39;, &#34;value&#34;),
        Input(&#39;drp-group-by&#39;, &#39;value&#39;),
        Input(&#39;radio_fuel&#39;, &#34;value&#34;),
        Input(&#39;dropdown_enduse&#39;, &#34;value&#34;),
        Input(&#39;radio_graph_type&#39;, &#34;value&#34;),
        Input(&#39;radio_savings&#39;, &#34;value&#34;),
        Input(&#39;dropdown_chng_type&#39;, &#34;value&#34;),
        Input(&#39;sync_upgrade&#39;, &#39;value&#39;),
        Input(&#39;input_building&#39;, &#39;value&#39;),
        Input(&#39;input_building&#39;, &#39;options&#39;),
        Input(&#39;input_building2&#39;, &#39;options&#39;),
        Input(&#39;chk-graph&#39;, &#39;value&#39;),
        State(&#34;uirevision&#34;, &#34;data&#34;),
        State(&#39;report_upgrade&#39;, &#39;value&#39;)
    )
    def update_figure(view_tab, grp_by, fuel, enduse, graph_type, savings_type, chng_type,
                      sync_upgrade, selected_bldg, bldg_options, bldg_options2, chk_graph, uirevision,
                      report_upgrade):
        nonlocal download_csv_df
        if dash.callback_context.triggered_id == &#39;input_building2&#39; and &#34;Graph&#34; not in chk_graph:
            raise PreventUpdate()

        if &#34;Graph&#34; in chk_graph and bldg_options2:
            bldg_options = bldg_options2

        bldg_options = bldg_options or []
        if not enduse:
            full_name = []
        if view_tab == &#39;energy&#39;:
            full_name = viz_data.get_end_use_db_cols(resolution, fuel, enduse)
        else:
            full_name = [enduse]

        if selected_bldg:
            filter_bldg = [int(selected_bldg)]
        else:
            filter_bldg = [int(b) for b in bldg_options]

        new_figure, report_df = get_plot(full_name, graph_type, savings_type,
                                         chng_type, sync_upgrade, filter_bldg, grp_by, report_upgrade)

        uirevision = uirevision or &#34;default&#34;
        new_figure.update_layout(uirevision=uirevision)
        download_csv_df = report_df
        config = {&#39;edits&#39;: {&#34;titleText&#34;: True, &#34;axisTitleText&#34;: True}, &#39;displayModeBar&#39;: True,
                  &#34;modeBarButtonsToRemove&#34;: [&#34;Zoom&#34;, &#34;ZoomIn&#34;, &#34;Pan&#34;, &#34;ZoomOut&#34;, &#34;AutoScale&#34;, &#34;select2d&#34;]}
        return new_figure, config, &#34;&#34;

    return app


def main():
    print(&#34;Welcome to Upgrades Visualizer.&#34;)
    yaml_path = inquirer.text(message=&#34;Please enter path to the buildstock configuration yml file: &#34;,
                              default=&#34;/Users/radhikar/Downloads/fact_sheets_category_6.yml&#34;).execute()
    opt_sat_path = inquirer.text(message=&#34;Please enter path to the options saturation csv file: &#34;,
                                 default=&#34;/Users/radhikar/Downloads/options_saturations.csv&#34;).execute()
    workgroup = inquirer.text(message=&#34;Please Athena workgroup name: &#34;,
                              default=&#34;largeee&#34;).execute()
    db_name = inquirer.text(message=&#34;Please enter database_name &#34;
                            &#34;(found in postprocessing:aws:athena in the buildstock configuration file): &#34;,
                            default=&#39;largeee_test_runs&#39;).execute()
    table_name = inquirer.text(message=&#34;Please enter table name (same as output folder name; found under &#34;
                               &#34;output_directory in the buildstock configuration file). [Enter two names &#34;
                               &#34;separated by comma if baseline and upgrades are in different run] :&#34;,
                               default=&#34;medium_run_baseline_20230622,medium_run_category_6_20230707&#34;
                               ).execute()

    if &#39;,&#39; in table_name:
        table_name = table_name.split(&#39;,&#39;)
    app = _get_app(yaml_path=yaml_path,
                   opt_sat_path=opt_sat_path,
                   workgroup=workgroup,
                   db_name=db_name,
                   table_name=table_name)
    app.run_server(debug=False, port=8005)


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.filter_cols"><code class="name flex">
<span>def <span class="ident">filter_cols</span></span>(<span>all_columns, prefixes=[], suffixes=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_cols(all_columns, prefixes=[], suffixes=[]):
    cols = []
    for col in all_columns:
        for prefix in prefixes:
            if col.startswith(prefix):
                cols.append(col)
                break
        else:
            for suffix in suffixes:
                if col.endswith(suffix):
                    cols.append(col)
                    break
    return cols</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.get_app"><code class="name flex">
<span>def <span class="ident">get_app</span></span>(<span>viz_data: <a title="buildstock_query.tools.upgrades_visualizer.viz_data.VizData" href="../upgrades_visualizer/viz_data.html#buildstock_query.tools.upgrades_visualizer.viz_data.VizData">VizData</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_app(viz_data: VizData):
    upgrades_plot = UpgradesPlot(viz_data)
    upgrade2res = viz_data.upgrade2res
    # upgrade2res_monthly = viz_data.upgrade2res_monthly
    upgrade2name = viz_data.upgrade2name
    resolution = &#39;annual&#39;
    all_cols = viz_data.upgrade2res[0].columns
    emissions_cols = filter_cols(all_cols, suffixes=[&#39;_lb&#39;])
    # end_use_cols = filter_cols(all_cols, [&#34;end_use_&#34;, &#34;energy_use__&#34;, &#34;fuel_use_&#34;])
    water_usage_cols = filter_cols(all_cols, suffixes=[&#34;_gal&#34;])
    load_cols = filter_cols(all_cols, [&#34;load_&#34;, &#34;flow_rate_&#34;])
    peak_cols = filter_cols(all_cols, [&#34;peak_&#34;])
    unmet_cols = filter_cols(all_cols, [&#34;unmet_&#34;])
    area_cols = filter_cols(all_cols, suffixes=[&#34;_ft_2&#34;, ])
    size_cols = filter_cols(all_cols, [&#34;size_&#34;])
    qoi_cols = filter_cols(all_cols, [&#34;qoi_&#34;])
    cost_cols = filter_cols(all_cols, [&#34;upgrade_cost_&#34;])
    build_cols = viz_data.metadata_df.columns
    char_cols = [c.removeprefix(viz_data.main_run.char_prefix) for c in build_cols if &#39;applicable&#39; not in c]
    char_cols += [&#39;month&#39;]
    fuels_types = [&#39;electricity&#39;, &#39;natural_gas&#39;, &#39;propane&#39;, &#39;fuel_oil&#39;, &#39;coal&#39;, &#39;wood_cord&#39;, &#39;wood_pellets&#39;]
    change_types = [&#34;any&#34;, &#34;no-chng&#34;, &#34;bad-chng&#34;, &#34;ok-chng&#34;, &#34;true-bad-chng&#34;, &#34;true-ok-chng&#34;]
    download_csv_df = pl.DataFrame()

    def get_buildings(upgrade):
        return upgrade2res[int(upgrade)][&#39;building_id&#39;].to_list()

    def get_plot(end_use, value_type=&#39;mean&#39;, savings_type=&#39;&#39;, change_type=&#39;&#39;,
                 sync_upgrade=None, filter_bldg=None, group_cols=None, report_upgrade=None):
        filter_bldg = filter_bldg or []
        group_cols = group_cols or []
        sync_upgrade = sync_upgrade or 0
        report_upgrade = int(report_upgrade) if report_upgrade else None

        params = PlotParams(enduses=end_use, value_type=ValueTypes[value_type.lower()],
                            savings_type=SavingsTypes[savings_type.lower().replace(&#39; &#39;, &#39;_&#39;)],
                            change_type=change_type, sync_upgrade=sync_upgrade,
                            filter_bldgs=filter_bldg, group_by=group_cols, upgrade=report_upgrade,
                            resolution=resolution)
        return upgrades_plot.get_plot(params)

    external_script = [&#34;https://tailwindcss.com/&#34;, {&#34;src&#34;: &#34;https://cdn.tailwindcss.com&#34;}]

    app = DashProxy(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], transforms=transforms,
                    external_scripts=external_script)
    app.layout = html.Div([dbc.Container(html.Div([
        dcc.Download(id=&#34;download-dataframe-csv&#34;),
        dbc.Row([dbc.Col(html.H1(&#34;Upgrades Visualizer&#34;), width=&#39;auto&#39;), dbc.Col(html.Sup(&#34;beta&#34;))]),
        # Add a row for annual, vs monthly vs seasonal plot radio buttons
        dbc.Row([dbc.Col(dbc.Label(&#34;Resolution: &#34;), width=&#39;auto&#39;),
                 dbc.Col(dcc.RadioItems([&#34;annual&#34;, &#34;monthly&#34;], &#34;annual&#34;,
                                        inline=True, id=&#34;radio_resolution&#34;))]),

        dbc.Row([dbc.Col(dbc.Label(&#34;Visualization Type: &#34;), width=&#39;auto&#39;),
                 dbc.Col(dcc.RadioItems([&#34;Mean&#34;, &#34;Total&#34;, &#34;Count&#34;, &#34;Distribution&#34;, &#34;Scatter&#34;], &#34;Mean&#34;,
                                        id=&#34;radio_graph_type&#34;,
                                        inline=True,
                                        labelClassName=&#34;pr-2&#34;), width=&#39;auto&#39;),
                 dbc.Col(dbc.Label(&#34;Value Type: &#34;), width=&#39;auto&#39;),
                 dbc.Col(dcc.RadioItems([&#34;Absolute&#34;, &#34;Savings&#34;, &#34;Percent Savings&#34;], &#34;Absolute&#34;,  inline=True,
                                        id=&#39;radio_savings&#39;, labelClassName=&#34;pr-2&#34;), width=&#39;auto&#39;),
                 ]),
        dbc.Row([dbc.Col(html.Br())]),
        dbc.Row([dbc.Col(dcc.Loading(id=&#39;graph-loader&#39;, children=[html.Div(id=&#39;loader_label&#39;)]))]),
        dbc.Row([dbc.Col(dcc.Graph(id=&#39;graph&#39;))]),
        dbc.Row([dbc.Col(dbc.Button(&#34;Download&#34;, id=&#39;csv-download&#39;))], justify=&#39;end&#39;),
        dcc.Store(id=&#39;graph-data-store&#39;),
    ])),
        dbc.Row([dbc.Col(
            dcc.Tabs(id=&#39;tab_view_type&#39;, value=&#39;energy&#39;, children=[
                dcc.Tab(id=&#39;energy_tab&#39;, label=&#39;Energy&#39;, value=&#39;energy&#39;, children=[
                    dcc.RadioItems(fuels_types + [&#39;All&#39;], &#34;electricity&#34;, id=&#39;radio_fuel&#39;,  inline=True,
                                   labelClassName=&#34;pr-2&#34;)]
                        ),
                dcc.Tab(label=&#39;Water Usage&#39;, value=&#39;water&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Load&#39;, value=&#39;load&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Peak&#39;, value=&#39;peak&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Unmet Hours&#39;, value=&#39;unmet_hours&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Area&#39;, value=&#39;area&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Size&#39;, value=&#39;size&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;QOI&#39;, value=&#39;qoi&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;emissions&#39;, value=&#39;emissions&#39;, children=[]
                        ),
                dcc.Tab(label=&#39;Upgrade Cost&#39;, value=&#39;upgrade_cost&#39;, children=[]
                        ),
            ])
        )
        ], className=&#34;mx-5 mt-5&#34;),
        dbc.Row([dbc.Col(dcc.Dropdown(id=&#39;dropdown_enduse&#39;))], className=&#34;mx-5 my-1&#34;),
        dbc.Row(
            dbc.Col([
                dbc.Row([dbc.Col(html.Div(&#34;Restrict to buildings that have &#34;), width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(change_types, &#34;&#34;, placeholder=&#34;Select change type...&#34;,
                                              id=&#39;dropdown_chng_type&#39;), width=&#39;2&#39;),
                         dbc.Col(html.Div(&#34; in &#34;), width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;sync_upgrade&#39;, value=&#39;&#39;,
                                              options={}))
                         ],
                        className=&#34;flex items-center&#34;),
                dbc.Row([dbc.Col(html.Div(&#34;Select:&#34;), style={&#34;padding-left&#34;: &#34;12px&#34;, &#34;padding-right&#34;: &#34;0px&#34;},
                                 width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;input_building&#39;), width=1),
                         dbc.Col(html.Div(&#34;(&#34;), width=&#39;auto&#39;,
                                 style={&#34;padding-left&#34;: &#34;0px&#34;, &#34;padding-right&#34;: &#34;0px&#34;}),
                         dbc.Col(dcc.Checklist([&#39;Lock)&#39;], [],
                                               inline=True, id=&#39;chk-lock&#39;),
                                 width=&#39;auto&#39;, style={&#34;padding-left&#34;: &#34;0px&#34;, &#34;padding-right&#34;: &#34;0px&#34;}),
                         dbc.Col(html.Div(&#34; in &#34;), style={&#34;padding-right&#34;: &#34;0px&#34;}, width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;report_upgrade&#39;, value=&#39;&#39;, placeholder=&#34;Upgrade ...&#34;,
                                              options=viz_data.upgrade2shortname), width=1),
                         dbc.Col(html.Div(&#34;grouped by:&#34;), style={&#34;padding-right&#34;: &#34;0px&#34;}, width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;drp-group-by&#39;, options=char_cols, value=None,
                                              multi=True, placeholder=&#34;Select characteristics...&#34;),
                                 width=3),
                         dbc.Col(dbc.Button(&#34;&lt;= Copy&#34;, id=&#34;btn-copy&#34;, color=&#34;primary&#34;, size=&#34;sm&#34;,
                                            outline=True), class_name=&#34;centered-col&#34;, style={&#34;padding-right&#34;: &#34;0px&#34;}),
                         dbc.Col(html.Div(&#34;Extra restriction: &#34;), style={&#34;padding-right&#34;: &#34;0px&#34;}, width=&#39;auto&#39;),
                         dbc.Col(dcc.Dropdown(id=&#39;input_building2&#39;, disabled=False), width=1),
                         dbc.Col(dcc.Checklist(id=&#39;chk-graph&#39;, options=[&#39;Graph&#39;], value=[],
                                               inline=True), width=&#39;auto&#39;),
                         dbc.Col(dcc.Checklist(id=&#39;chk-options&#39;, options=[&#39;Options&#39;], value=[],
                                               inline=True), width=&#39;auto&#39;),
                         dbc.Col(dcc.Checklist(id=&#39;chk-enduses&#39;, options=[&#39;Enduses&#39;], value=[],
                                               inline=True), width=&#39;auto&#39;),
                         dbc.Col(dcc.Checklist(id=&#39;chk-chars&#39;, options=[&#39;Chars&#39;], value=[],
                                               inline=True), width=&#39;auto&#39;),
                         dbc.Col(dbc.Button(&#34;Reset&#34;, id=&#34;btn-reset&#34;, color=&#34;primary&#34;, size=&#34;sm&#34;, outline=True),
                                 width=&#39;auto&#39;),
                         ]),
                dbc.Row([dbc.Col([
                    dbc.Row(html.Div(id=&#34;options_report_header&#34;)),
                    dbc.Row(dcc.Loading(id=&#39;opt-loader&#39;,
                                        children=html.Div(id=&#34;options_report&#34;))),
                    dcc.Store(&#34;opt_report_store&#34;)
                ], width=5),
                    dbc.Col([
                        dbc.Row([dbc.Col(html.Div(&#34;View enduse that: &#34;), width=&#39;auto&#39;),
                                 dbc.Col(dcc.Dropdown(id=&#39;input_enduse_type&#39;,
                                                      options=[&#39;changed&#39;, &#39;increased&#39;, &#39;decreased&#39;, &#39;are almost zero&#39;],
                                                      value=&#39;changed&#39;, clearable=False),
                                         width=2),
                                 dbc.Col(html.Div(), width=&#39;auto&#39;),
                                 dbc.Col(html.Div(&#34;Charecteristics Report:&#34;), width=&#39;auto&#39;),
                                 dbc.Col(dcc.Dropdown(id=&#39;drp-char-report&#39;, options=char_cols, value=None,
                                                      multi=True, placeholder=&#34;Select characteristics...&#34;)),
                                 ]),
                        dbc.Row([dbc.Col(dcc.Loading(id=&#39;enduse_loader&#39;,
                                                     children=html.Div(id=&#34;enduse_report&#34;))
                                         ),
                                 dbc.Col(dcc.Loading(id=&#39;char_loader&#39;,
                                                     children=html.Div(id=&#34;char_report&#34;))
                                         ),
                                 ]),
                        dcc.Store(&#34;enduse_report_store&#34;),
                        dcc.Store(&#34;char_report_store&#34;)
                    ], width=7)

                ]),
                dbc.Row([
                    dbc.Col(width=5),
                    dbc.Col(
                        dbc.Row([
                            dbc.Col(),
                            dbc.Col(dbc.Button(&#34;Download All Characteristics&#34;, id=&#34;btn-dwn-chars&#34;,
                                               color=&#34;primary&#34;,
                                               size=&#34;sm&#34;, outline=True), width=&#39;auto&#39;),
                        ]), width=7)
                ])
            ]), className=&#34;mx-5 my-1&#34;),
        html.Div(id=&#34;status_bar&#34;),
        dcc.Download(id=&#34;download-chars-csv&#34;),
        dcc.Store(&#34;uirevision&#34;)
        # dbc.Button(&#34;Kill me&#34;, id=&#34;button110&#34;)
    ])

    # download data with button click
    @app.callback(
        Output(&#34;download-dataframe-csv&#34;, &#34;data&#34;),
        Input(&#34;csv-download&#34;, &#34;n_clicks&#34;),
        prevent_initial_call=True)
    def download_csv(n_clicks):
        if not n_clicks:
            raise PreventUpdate()
        nonlocal download_csv_df
        return dcc.send_bytes(download_csv_df.write_csv, &#34;graph_data.csv&#34;)

    @app.callback(
        Output(&#34;download-chars-csv&#34;, &#34;data&#34;),
        Input(&#34;btn-dwn-chars&#34;, &#34;n_clicks&#34;),
        State(&#34;input_building&#34;, &#34;value&#34;),
        State(&#34;input_building&#34;, &#34;options&#34;),
        State(&#34;input_building2&#34;, &#34;options&#34;),
        State(&#39;chk-chars&#39;, &#39;value&#39;),
    )
    def download_char(n_clicks, bldg_id, bldg_options, bldg_options2, chk_chars):
        if not n_clicks:
            raise PreventUpdate()

        if &#34;Chars&#34; in chk_chars and bldg_options2:
            bldg_ids = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options2]
        else:
            bldg_ids = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options]
        bldg_ids = [int(b) for b in bldg_ids]
        bdf = viz_data.upgrade2res[0].filter(pl.col(&#34;building_id&#34;).is_in(set(bldg_ids))).select(char_cols)
        return dcc.send_bytes(bdf.write_csv, f&#34;chars_{n_clicks}.csv&#34;)

    def get_elligible_output_columns(category, fuel):
        if category == &#39;energy&#39;:
            elligible_cols = viz_data.get_cleaned_up_end_use_cols(resolution, fuel)
        elif category == &#39;water&#39;:
            elligible_cols = water_usage_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;load&#39;:
            elligible_cols = load_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;peak&#39;:
            elligible_cols = peak_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;unmet_hours&#39;:
            elligible_cols = unmet_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;area&#39;:
            elligible_cols = area_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;size&#39;:
            elligible_cols = size_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;qoi&#39;:
            elligible_cols = qoi_cols if resolution == &#39;annual&#39; else []
        elif category == &#39;emissions&#39;:
            elligible_cols = emissions_cols if resolution == &#39;annual&#39; else\
                             viz_data.get_emissions_cols(resolution=resolution)
        elif category == &#39;upgrade_cost&#39;:
            elligible_cols = cost_cols if resolution == &#39;annual&#39; else []
        else:
            raise ValueError(f&#34;Invalid tab {category}&#34;)
        return elligible_cols

    @app.callback(
            Output(&#39;radio_resolution&#39;, &#39;options&#39;),
            Input(&#39;radio_resolution&#39;, &#39;value&#39;),
    )
    def update_resolution(res):
        nonlocal resolution
        resolution = res
        return [&#39;annual&#39;, &#39;monthly&#39;]

    @app.callback(
        Output(&#39;dropdown_enduse&#39;, &#34;options&#34;),
        Output(&#39;dropdown_enduse&#39;, &#34;value&#34;),
        Input(&#39;tab_view_type&#39;, &#34;value&#34;),
        Input(&#39;radio_fuel&#39;, &#34;value&#34;),
        Input(&#39;dropdown_enduse&#39;, &#34;value&#34;),
        Input(&#39;radio_resolution&#39;, &#39;value&#39;)
    )
    def update_enduse_options(view_tab, fuel_type, current_enduse, resolution):
        elligible_cols = get_elligible_output_columns(view_tab, fuel_type)
        enduse = current_enduse if current_enduse in elligible_cols else elligible_cols[0]
        return sorted(elligible_cols), enduse

    @app.callback(
        Output(&#34;sync_upgrade&#34;, &#39;value&#39;),
        Output(&#34;sync_upgrade&#34;, &#39;options&#39;),
        Output(&#34;sync_upgrade&#34;, &#39;placeholder&#39;),
        Input(&#39;dropdown_chng_type&#39;, &#34;value&#34;),
        State(&#34;sync_upgrade&#34;, &#34;value&#34;),
        State(&#34;sync_upgrade&#34;, &#34;options&#34;)
    )
    def update_sync_upgrade(chng_type, current_sync_upgrade, sync_upgrade_options):
        # print(chng_type, current_sync_upgrade, sync_upgrade_options)
        if chng_type:
            return current_sync_upgrade, upgrade2name, &#39;respective upgrades. (Click to restrict to specific upgrade)&#39;
        else:
            return &#39;&#39;, {}, &#39; &lt;select a change type on the left first&gt;&#39;

    @app.callback(
        Output(&#39;input_building&#39;, &#39;placeholder&#39;),
        Input(&#39;input_building&#39;, &#39;options&#39;)
    )
    def update_building_placeholder(options):
        return f&#34;{len(options)} Buidlings&#34; if options else &#34;0 buildings.&#34;

    @app.callback(
        Output(&#39;input_building2&#39;, &#39;placeholder&#39;),
        Output(&#39;input_building2&#39;, &#39;value&#39;),
        Input(&#39;input_building2&#39;, &#39;value&#39;),
        Input(&#39;input_building2&#39;, &#39;options&#39;)
    )
    def update_building_placeholder2(value, options):
        return f&#34;{len(options)} Buidlings&#34; if options else &#34;No restriction&#34;, None

    @app.callback(
        Output(&#39;input_building&#39;, &#39;value&#39;),
        Output(&#39;input_building&#39;, &#39;options&#39;),
        Output(&#39;report_upgrade&#39;, &#39;value&#39;),
        Input(&#39;graph&#39;, &#34;selectedData&#34;),
        State(&#39;input_building&#39;, &#39;options&#39;),
        State(&#39;report_upgrade&#39;, &#39;value&#39;)
    )
    def graph_click(selection_data, current_options, current_upgrade):
        if not selection_data or &#39;points&#39; not in selection_data or len(selection_data[&#39;points&#39;]) &lt; 1:
            raise PreventUpdate()

        selected_buildings = []
        selected_upgrades = []
        for point in selection_data[&#39;points&#39;]:
            if not (match := re.search(r&#34;Building: (\d*)&#34;, point.get(&#39;hovertext&#39;, &#39;&#39;))):
                continue
            if bldg := match.groups()[0]:
                upgrade_match = re.search(r&#34;Upgrade (\d*)&#34;, point.get(&#39;hovertext&#39;, &#39;&#39;))
                upgrade = upgrade_match.groups()[0] if upgrade_match else &#39;&#39;
                selected_buildings.append(bldg)
                selected_upgrades.append(upgrade)

        if not selected_buildings:
            raise PreventUpdate()

        selected_upgrade = selected_upgrades[0] or current_upgrade
        if len(selected_buildings) != 1:
            selected_buildings = list(set(selected_buildings))
            return &#39;&#39;, selected_buildings, selected_upgrade
        current_options = current_options or selected_buildings
        return selected_buildings[0], current_options, selected_upgrade

    @app.callback(
        Output(&#39;chk-graph&#39;, &#39;value&#39;),
        Output(&#39;chk-options&#39;, &#39;value&#39;),
        Output(&#39;chk-enduses&#39;, &#39;value&#39;),
        Output(&#39;input_building2&#39;, &#39;options&#39;),
        Output(&#34;uirevision&#34;, &#34;data&#34;),
        Input(&#39;btn-reset&#39;, &#34;n_clicks&#34;)
    )
    def reset(n_clicks):
        return [], [], [], [], n_clicks

    @app.callback(
        Output(&#39;input_building&#39;, &#39;options&#39;),
        Input(&#39;btn-copy&#39;, &#34;n_clicks&#34;),
        State(&#39;input_building2&#39;, &#39;options&#39;),
    )
    def copy(n_clicks, bldg_options2):
        return bldg_options2 or dash.no_update

    @app.callback(
        Output(&#39;input_building&#39;, &#39;value&#39;),
        Output(&#39;input_building&#39;, &#39;options&#39;),
        Output(&#39;input_building2&#39;, &#39;options&#39;),
        State(&#39;input_building&#39;, &#39;value&#39;),
        State(&#39;input_building&#39;, &#39;options&#39;),
        State(&#39;input_building2&#39;, &#39;options&#39;),
        Input(&#39;chk-lock&#39;, &#39;value&#39;),
        Input(&#39;dropdown_chng_type&#39;, &#34;value&#34;),
        Input(&#39;sync_upgrade&#39;, &#39;value&#39;),
        Input(&#39;report_upgrade&#39;, &#39;value&#39;),
        Input(&#39;btn-reset&#39;, &#34;n_clicks&#34;)
    )
    def bldg_selection(current_bldg, current_options, current_options2, chk_lock,
                       change_type, sync_upgrade, report_upgrade,
                       reset_click):

        if sync_upgrade and change_type:
            valid_bldgs = set(viz_data.chng2bldg[(int(sync_upgrade), change_type)])
        elif report_upgrade and change_type:
            valid_bldgs = set(viz_data.chng2bldg[(int(report_upgrade), change_type)])
            buildings = get_buildings(report_upgrade)
            valid_bldgs = set(buildings).intersection(valid_bldgs)
        elif report_upgrade:
            buildings = get_buildings(report_upgrade)
            valid_bldgs = set(buildings)
        else:
            valid_bldgs = set(viz_data.upgrade2res[0][&#39;building_id&#39;].to_list())

        base_res = upgrade2res[0].filter(pl.col(&#34;building_id&#34;).is_in(valid_bldgs))
        valid_bldgs = list(base_res[&#39;building_id&#39;].to_list())

        if &#34;btn-reset&#34; != ctx.triggered_id and current_options and len(current_options) &gt; 0 and chk_lock:
            current_options_set = set(current_options)
            valid_bldgs = [b for b in valid_bldgs if b in current_options_set]

        valid_bldgs2 = []

        if current_bldg and (int(current_bldg) not in valid_bldgs):
            current_bldg = valid_bldgs[0] if valid_bldgs else &#39;&#39;
        return current_bldg, valid_bldgs, valid_bldgs2

    def get_char_choices(char):
        if char:
            res0 = upgrade2res[0]
            unique_choices = sorted(list(res0[char].unique()))
            return unique_choices, unique_choices[0]
        else:
            return [], None

    def get_action_button_pairs(id, bldg_list_dict, report_type=&#39;opt&#39;):
        buttons = []
        bldg_str = &#39;&#39; if len(bldg_list_dict[id]) &gt; 10 else &#34; [&#34; + &#39;,&#39;.join([str(b) for b in bldg_list_dict[id]]) + &#34;]&#34;
        for type in [&#39;check&#39;, &#39;cross&#39;]:
            icon_name = &#34;akar-icons:circle-check-fill&#34; if type == &#39;check&#39; else &#34;gridicons:cross-circle&#34;
            button = html.Div(dmc.ActionIcon(DashIconify(icon=icon_name,
                                                         width=20 if type == &#34;check&#34; else 22,
                                                         height=20 if type == &#34;check&#34; else 22,
                                                         ),
                                             id={&#39;index&#39;: id, &#39;type&#39;: f&#39;btn-{type}&#39;, &#39;report_type&#39;: report_type},
                                             variant=&#34;light&#34;),
                              id=f&#34;div-tooltip-target-{type}-{id}&#34;)
            if type == &#34;check&#34;:
                tooltip = dbc.Tooltip(f&#34;Select these buildings.{bldg_str}&#34;,
                                      target=f&#34;div-tooltip-target-{type}-{id}&#34;, delay={&#39;show&#39;: 1000})

                col = dbc.Col(html.Div([button, tooltip]),  width=&#39;auto&#39;, class_name=&#34;col-btn-cross&#34;,
                              style={&#34;padding-left&#34;: &#34;0px&#34;, &#34;padding-right&#34;: &#34;0px&#34;})
            else:
                tooltip = dbc.Tooltip(f&#34;Select all except these buildings.{bldg_str}&#34;,
                                      target=f&#34;div-tooltip-target-{type}-{id}&#34;, delay={&#39;show&#39;: 1000})
                col = dbc.Col(html.Div([button, tooltip]),  width=&#39;auto&#39;,  class_name=&#34;col-btn-check&#34;,
                              style={&#34;padding-left&#34;: &#34;0px&#34;, &#34;padding-right&#34;: &#34;0px&#34;})
            buttons.append(col)
        return buttons

    @app.callback(
        Output(&#39;status_bar&#39;, &#34;children&#34;),
        Output(&#39;input_building2&#39;, &#34;options&#34;),
        Input({&#34;type&#34;: &#34;btn-check&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;opt&#34;}, &#34;n_clicks&#34;),
        Input({&#34;type&#34;: &#34;btn-cross&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;opt&#34;}, &#34;n_clicks&#34;),
        State(&#34;input_building&#34;, &#34;options&#34;),
        State(&#34;input_building2&#34;, &#34;options&#34;),
        State(&#34;chk-options&#34;, &#34;value&#34;),
        State(&#34;opt_report_store&#34;, &#34;data&#34;),
    )
    def opt_check_button_click(check_clicks, cross_clicks, bldg_options, bldg_options2, chk_options, opt_report):
        triggers = dash.callback_context.triggered_prop_ids
        if len(triggers) != 1:
            raise PreventUpdate()

        if &#34;Options&#34; in chk_options and bldg_options2:
            bldg_list = [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(b) for b in bldg_options]

        trigger_val = next(iter(triggers.values()))
        buildings = opt_report.get(trigger_val[&#39;index&#39;], [])
        if trigger_val[&#39;type&#39;] == &#39;btn-check&#39;:
            return &#39;&#39;, [str(b) for b in buildings]

        bldg_set = set(buildings)
        except_buildings = [str(v) for v in bldg_list if int(v) not in bldg_set]
        return &#39;&#39;, except_buildings

    @app.callback(
        Output(&#39;status_bar&#39;, &#34;children&#34;),
        Output(&#39;input_building2&#39;, &#34;options&#34;),
        Input({&#34;type&#34;: &#34;btn-check&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;enduse&#34;}, &#34;n_clicks&#34;),
        Input({&#34;type&#34;: &#34;btn-cross&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;enduse&#34;}, &#34;n_clicks&#34;),
        State(&#34;input_building&#34;, &#34;options&#34;),
        State(&#34;input_building2&#34;, &#34;options&#34;),
        State(&#34;chk-enduses&#34;, &#34;value&#34;),
        State(&#34;enduse_report_store&#34;, &#34;data&#34;),
    )
    def enduse_button_click(check_clicks, cross_clicks, bldg_options, bldg_options2, chk_enduses, opt_report):
        triggers = dash.callback_context.triggered_prop_ids
        if len(triggers) != 1:
            raise PreventUpdate()

        if &#34;Enduses&#34; in chk_enduses and bldg_options2:
            bldg_list = [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(b) for b in bldg_options]

        trigger_val = next(iter(triggers.values()))
        buildings = opt_report.get(trigger_val[&#39;index&#39;], [])
        if trigger_val[&#39;type&#39;] == &#39;btn-check&#39;:
            return &#39;&#39;, [str(b) for b in buildings]

        bldg_set = set(buildings)
        except_buildings = [str(v) for v in bldg_list if int(v) not in bldg_set]
        return &#39;&#39;, except_buildings

    @app.callback(
        Output(&#39;status_bar&#39;, &#34;children&#34;),
        Output(&#39;input_building2&#39;, &#34;options&#34;),
        Input({&#34;type&#34;: &#34;btn-check&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;char&#34;}, &#34;n_clicks&#34;),
        Input({&#34;type&#34;: &#34;btn-cross&#34;, &#34;index&#34;: ALL, &#34;report_type&#34;: &#34;char&#34;}, &#34;n_clicks&#34;),
        State(&#34;input_building&#34;, &#34;options&#34;),
        State(&#34;input_building2&#34;, &#34;options&#34;),
        State(&#39;chk-chars&#39;, &#39;value&#39;),
        State(&#34;char_report_store&#34;, &#34;data&#34;),
    )
    def char_report_button_click(check_clicks, cross_clicks, bldg_options, bldg_options2, chk_char, char_report):
        triggers = dash.callback_context.triggered_prop_ids
        if len(triggers) != 1:
            raise PreventUpdate()

        if &#34;Chars&#34; in chk_char and bldg_options2:
            bldg_list = [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(b) for b in bldg_options]

        trigger_val = next(iter(triggers.values()))
        buildings = char_report.get(trigger_val[&#39;index&#39;], [])
        if trigger_val[&#39;type&#39;] == &#39;btn-check&#39;:
            return &#39;&#39;, [str(b) for b in buildings]

        bldg_set = set(buildings)
        except_buildings = [str(v) for v in bldg_list if int(v) not in bldg_set]
        return &#39;&#39;, except_buildings

    @app.callback(
        Output(&#34;options_report_header&#34;, &#34;children&#34;),
        Output(&#34;options_report&#34;, &#39;children&#39;),
        Output(&#34;opt_report_store&#34;, &#34;data&#34;),
        Input(&#39;input_building&#39;, &#34;value&#34;),
        Input(&#39;input_building&#39;, &#34;options&#34;),
        Input(&#39;input_building2&#39;, &#34;options&#34;),
        State(&#39;report_upgrade&#39;, &#39;value&#39;),
        Input(&#39;chk-options&#39;, &#39;value&#39;),
    )
    def show_opt_report(bldg_id, bldg_options, bldg_options2, report_upgrade, chk_options):
        if not report_upgrade or not bldg_options:
            return &#34;Select an upgrade to see options applied in that upgrade&#34;, [&#39;&#39;], {}

        if dash.callback_context.triggered_id == &#39;input_building2&#39; and &#34;Options&#34; not in chk_options:
            raise PreventUpdate()

        if &#34;Options&#34; in chk_options and bldg_options2:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options]
        run_obj = viz_data.run_obj(int(report_upgrade))
        applied_options = run_obj.report.get_applied_options(upgrade_id=int(report_upgrade),
                                                             bldg_ids=bldg_list,
                                                             include_base_opt=True)
        opt_only = [{entry.split(&#39;|&#39;)[0] for entry in opt.keys()} for opt in applied_options]
        reduced_set = list(reduce(set.union, opt_only))

        nested_dict = defaultdict(lambda: defaultdict(Counter))
        bldg_list_dict = defaultdict(list)

        for bldg_id, opt_dict in zip(bldg_list, applied_options):
            for opt_para, value in opt_dict.items():
                opt = opt_para.split(&#39;|&#39;)[0]
                para = opt_para.split(&#39;|&#39;)[1]
                nested_dict[opt][para][value] += 1
                bldg_list_dict[opt].append(bldg_id)
                bldg_list_dict[opt + &#34;|&#34; + para].append(bldg_id)
                bldg_list_dict[opt + &#34;|&#34; + para + &#34;&lt;-&#34; + value].append(bldg_id)

        def get_accord_item(opt_name):
            total_count = sum(counter.total() for counter in nested_dict[opt_name].values())
            children = []
            for parameter, counter in nested_dict[opt_name].items():
                contents = []
                new_counter = Counter({&#34;All&#34;: counter.total()})
                new_counter.update(counter)
                for from_val, count in new_counter.items():
                    if from_val == &#34;All&#34;:
                        but_ids = f&#34;{opt_name}|{parameter}&#34;
                    else:
                        but_ids = f&#34;{opt_name}|{parameter}&lt;-{from_val}&#34;
                    entry = dbc.Row([dbc.Col(f&#34;&lt;-{from_val} ({count})&#34;, width=&#34;auto&#34;),
                                     *get_action_button_pairs(but_ids, bldg_list_dict)])
                    contents.append(entry)
                children.append(dmc.AccordionItem(contents, label=f&#34;{parameter} ({counter.total()})&#34;))

            accordian = dmc.Accordion(children, multiple=True)
            first_row = dbc.Row([dbc.Col(f&#34;All ({total_count})&#34;, width=&#34;auto&#34;),
                                 *get_action_button_pairs(opt_name, bldg_list_dict)])
            return dmc.AccordionItem([first_row, accordian], label=f&#34;{opt_name} ({total_count})&#34;)
        if reduced_set:
            final_report = dmc.Accordion([get_accord_item(opt_name) for opt_name in reduced_set], multiple=True)
        else:
            final_report = [&#34;No option got applied to the selected building(s).&#34;]
        up_name = upgrade2name[int(report_upgrade)]
        return f&#34;Options applied in {up_name}&#34;, final_report, dict(bldg_list_dict)

    @app.callback(
        Output(&#34;enduse_report&#34;, &#34;children&#34;),
        Output(&#34;enduse_report_store&#34;, &#34;data&#34;),
        State(&#39;report_upgrade&#39;, &#39;value&#39;),
        Input(&#39;input_building&#39;, &#34;value&#34;),
        Input(&#39;input_building&#39;, &#34;options&#34;),
        Input(&#39;input_building2&#39;, &#34;options&#34;),
        Input(&#39;input_enduse_type&#39;, &#39;value&#39;),
        Input(&#39;chk-enduses&#39;, &#39;value&#39;),
    )
    def show_enduse_report(report_upgrade, bldg_id, bldg_options, bldg_options2, enduse_change_type, chk_enduse):
        if not report_upgrade or not bldg_options:
            return [&#34;Select an upgrade to see enuse report.&#34;], {}

        if dash.callback_context.triggered_id == &#39;input_building2&#39; and &#34;Enduses&#34; not in chk_enduse:
            raise PreventUpdate()

        if &#34;Enduses&#34; in chk_enduse and bldg_options2:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options]

        # print(bldg_list)
        run_obj = viz_data.run_obj(int(report_upgrade))
        dict_changed_enduses = run_obj.report.get_enduses_buildings_map_by_change(upgrade_id=int(report_upgrade),
                                                                                  change_type=enduse_change_type,
                                                                                  bldg_list=bldg_list)
        # print(changed_enduses)

        all_changed_enduses = list(dict_changed_enduses.keys())
        if not all_changed_enduses:
            if bldg_id:
                return f&#39;No enduse has {enduse_change_type} in building {bldg_id} &#39;, {}
            else:
                return f&#39;No enduse has {enduse_change_type} in any of the buildings&#39;, {}

        enduses2bldgs = defaultdict(list)
        for end_use, bldgs in dict_changed_enduses.items():
            if end_use in all_changed_enduses:
                enduses2bldgs[end_use].extend([int(bldg_id) for bldg_id in bldgs])

        fuel2bldgs = defaultdict(set)
        fuel2enduses = defaultdict(list)
        for enduse, bldgs in enduses2bldgs.items():
            for fuel in [&#39;all_fuel&#39;] + fuels_types:
                if fuel in enduse:
                    fuel2bldgs[fuel] |= set(bldgs)
                    fuel2enduses[fuel].append(enduse)
                    break
            else:
                fuel2bldgs[&#39;other&#39;] |= set(bldgs)
                fuel2enduses[&#39;other&#39;].append(enduse)

        for key, val in fuel2bldgs.items():
            fuel2bldgs[key] = list(val)

        enduses2bldgs.update(fuel2bldgs)

        def get_accord_item(fuel):
            total_count = len(enduses2bldgs[fuel])
            contents = [dbc.Row([dbc.Col(f&#34;All {fuel} ({total_count})&#34;, width=&#34;auto&#34;),
                                 *get_action_button_pairs(fuel, enduses2bldgs, &#34;enduse&#34;)])]
            for enduse in fuel2enduses[fuel]:
                count = len(enduses2bldgs[enduse])
                row = dbc.Row([dbc.Col(f&#34;{enduse} ({count})&#34;, width=&#34;auto&#34;),
                               *get_action_button_pairs(enduse, enduses2bldgs, &#34;enduse&#34;)])
                contents.append(row)
            return dmc.AccordionItem(contents, label=f&#34;{fuel} ({total_count})&#34;)

        report = dmc.Accordion([get_accord_item(fuel) for fuel in fuel2enduses.keys()],  multiple=True)
        storedict = dict(enduses2bldgs)
        return report, storedict

    @app.callback(
        Output(&#34;char_report&#34;, &#34;children&#34;),
        Output(&#34;char_report_store&#34;, &#34;data&#34;),
        Input(&#39;input_building&#39;, &#34;value&#34;),
        Input(&#39;input_building&#39;, &#34;options&#34;),
        Input(&#39;input_building2&#39;, &#34;options&#34;),
        Input(&#39;drp-char-report&#39;, &#39;value&#39;),
        Input(&#39;chk-chars&#39;, &#39;value&#39;),
    )
    def show_char_report(bldg_id, bldg_options, bldg_options2, inp_char: list[str], chk_chars):
        if not (bldg_options or bldg_options2 or bldg_id):
            return [&#34;&#34;], {}
        if not inp_char:
            return [&#34;Select a characteristics to see its report.&#34;], {}

        if dash.callback_context.triggered_id == &#39;input_building2&#39; and &#34;Chars&#34; not in chk_chars:
            raise PreventUpdate()

        if &#34;Chars&#34; in chk_chars and bldg_options2:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options2]
        else:
            bldg_list = [int(bldg_id)] if bldg_id else [int(b) for b in bldg_options]
        chars_df = viz_data.bs_res_df.filter(pl.col(&#39;building_id&#39;).is_in(
                    set(bldg_list))).select(inp_char + [&#39;building_id&#39;])
        char2bldgs = chars_df.groupby(inp_char).agg(&#39;building_id&#39;)
        if (total_len := len(char2bldgs)) &gt; 250:
            return [f&#34;Sorry, this would create more than 200 ({total_len}) rows.&#34;], {}
        char_dict = {}
        total_count = 0
        contents = []
        for char_vals, group_df in chars_df.groupby(inp_char):
            bldglist = group_df[&#39;building_id&#39;].to_list()
            but_ids = &#34;+&#34;.join(char_vals) if isinstance(char_vals, tuple) else char_vals
            char_dict[but_ids] = [int(b) for b in bldglist]
            count = len(bldglist)
            total_count += count
            contents.append(dbc.Row([dbc.Col(f&#34;{char_vals} ({count})&#34;, width=&#34;auto&#34;),
                                     *get_action_button_pairs(but_ids, char_dict, &#34;char&#34;)]))

        report = dmc.Accordion([dmc.AccordionItem(contents, label=f&#34;{inp_char} ({total_count})&#34;)])
        return report, char_dict

    @app.callback(
        Output(&#39;graph&#39;, &#39;figure&#39;),
        Output(&#39;graph&#39;, &#39;config&#39;),
        Output(&#39;loader_label&#39;, &#34;children&#34;),
        State(&#39;tab_view_type&#39;, &#34;value&#34;),
        Input(&#39;drp-group-by&#39;, &#39;value&#39;),
        Input(&#39;radio_fuel&#39;, &#34;value&#34;),
        Input(&#39;dropdown_enduse&#39;, &#34;value&#34;),
        Input(&#39;radio_graph_type&#39;, &#34;value&#34;),
        Input(&#39;radio_savings&#39;, &#34;value&#34;),
        Input(&#39;dropdown_chng_type&#39;, &#34;value&#34;),
        Input(&#39;sync_upgrade&#39;, &#39;value&#39;),
        Input(&#39;input_building&#39;, &#39;value&#39;),
        Input(&#39;input_building&#39;, &#39;options&#39;),
        Input(&#39;input_building2&#39;, &#39;options&#39;),
        Input(&#39;chk-graph&#39;, &#39;value&#39;),
        State(&#34;uirevision&#34;, &#34;data&#34;),
        State(&#39;report_upgrade&#39;, &#39;value&#39;)
    )
    def update_figure(view_tab, grp_by, fuel, enduse, graph_type, savings_type, chng_type,
                      sync_upgrade, selected_bldg, bldg_options, bldg_options2, chk_graph, uirevision,
                      report_upgrade):
        nonlocal download_csv_df
        if dash.callback_context.triggered_id == &#39;input_building2&#39; and &#34;Graph&#34; not in chk_graph:
            raise PreventUpdate()

        if &#34;Graph&#34; in chk_graph and bldg_options2:
            bldg_options = bldg_options2

        bldg_options = bldg_options or []
        if not enduse:
            full_name = []
        if view_tab == &#39;energy&#39;:
            full_name = viz_data.get_end_use_db_cols(resolution, fuel, enduse)
        else:
            full_name = [enduse]

        if selected_bldg:
            filter_bldg = [int(selected_bldg)]
        else:
            filter_bldg = [int(b) for b in bldg_options]

        new_figure, report_df = get_plot(full_name, graph_type, savings_type,
                                         chng_type, sync_upgrade, filter_bldg, grp_by, report_upgrade)

        uirevision = uirevision or &#34;default&#34;
        new_figure.update_layout(uirevision=uirevision)
        download_csv_df = report_df
        config = {&#39;edits&#39;: {&#34;titleText&#34;: True, &#34;axisTitleText&#34;: True}, &#39;displayModeBar&#39;: True,
                  &#34;modeBarButtonsToRemove&#34;: [&#34;Zoom&#34;, &#34;ZoomIn&#34;, &#34;Pan&#34;, &#34;ZoomOut&#34;, &#34;AutoScale&#34;, &#34;select2d&#34;]}
        return new_figure, config, &#34;&#34;

    return app</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    print(&#34;Welcome to Upgrades Visualizer.&#34;)
    yaml_path = inquirer.text(message=&#34;Please enter path to the buildstock configuration yml file: &#34;,
                              default=&#34;/Users/radhikar/Downloads/fact_sheets_category_6.yml&#34;).execute()
    opt_sat_path = inquirer.text(message=&#34;Please enter path to the options saturation csv file: &#34;,
                                 default=&#34;/Users/radhikar/Downloads/options_saturations.csv&#34;).execute()
    workgroup = inquirer.text(message=&#34;Please Athena workgroup name: &#34;,
                              default=&#34;largeee&#34;).execute()
    db_name = inquirer.text(message=&#34;Please enter database_name &#34;
                            &#34;(found in postprocessing:aws:athena in the buildstock configuration file): &#34;,
                            default=&#39;largeee_test_runs&#39;).execute()
    table_name = inquirer.text(message=&#34;Please enter table name (same as output folder name; found under &#34;
                               &#34;output_directory in the buildstock configuration file). [Enter two names &#34;
                               &#34;separated by comma if baseline and upgrades are in different run] :&#34;,
                               default=&#34;medium_run_baseline_20230622,medium_run_category_6_20230707&#34;
                               ).execute()

    if &#39;,&#39; in table_name:
        table_name = table_name.split(&#39;,&#39;)
    app = _get_app(yaml_path=yaml_path,
                   opt_sat_path=opt_sat_path,
                   workgroup=workgroup,
                   db_name=db_name,
                   table_name=table_name)
    app.run_server(debug=False, port=8005)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="buildstock_query.tools.characteristics_visualizer" href="index.html">buildstock_query.tools.characteristics_visualizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.filter_cols" href="#buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.filter_cols">filter_cols</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.get_app" href="#buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.get_app">get_app</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.main" href="#buildstock_query.tools.characteristics_visualizer.upgrades_visualizer.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>