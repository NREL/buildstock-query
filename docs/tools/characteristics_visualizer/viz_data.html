<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>buildstock_query.tools.characteristics_visualizer.viz_data API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buildstock_query.tools.characteristics_visualizer.viz_data</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from buildstock_query import BuildStockQuery, KWH2MBTU
from pydantic import validate_arguments
import polars as pl
from buildstock_query.tools.upgrades_visualizer.plot_utils import PlotParams
from typing import Union

num2month = {1: &#34;January&#34;, 2: &#34;February&#34;, 3: &#34;March&#34;, 4: &#34;April&#34;,
             5: &#34;May&#34;, 6: &#34;June&#34;, 7: &#34;July&#34;, 8: &#34;August&#34;,
             9: &#34;September&#34;, 10: &#34;October&#34;, 11: &#34;November&#34;, 12: &#34;December&#34;}
fuels_types = [&#39;electricity&#39;, &#39;natural_gas&#39;, &#39;propane&#39;, &#39;fuel_oil&#39;, &#39;coal&#39;, &#39;wood_cord&#39;, &#39;wood_pellets&#39;]


class VizData:
    @validate_arguments(config=dict(arbitrary_types_allowed=True, smart_union=True))
    def __init__(self, yaml_path: str, opt_sat_path: str,
                 db_name: str,
                 run: Union[str, tuple[str, str]],
                 workgroup: str = &#39;largeee&#39;,
                 buildstock_type: str = &#39;resstock&#39;,
                 skip_init: bool = False):
        if isinstance(run, tuple):
            # Allows for separate baseline and upgrade runs
            # In this case, run[0] is the baseline run and run[1] is the upgrade run
            self.baseline_run = BuildStockQuery(workgroup=workgroup,
                                                db_name=db_name,
                                                buildstock_type=buildstock_type,
                                                table_name=run[0],
                                                skip_reports=skip_init)
            baseline_table_name = run[0] + &#34;_baseline&#34;
            upgrade_table_name = run[1] + &#34;_upgrades&#34;
            ts_table_name = run[1] + &#34;_timeseries&#34;
            table = (baseline_table_name, ts_table_name, upgrade_table_name)
        else:
            # If only one run is specified, it is assumed to contain both baseline and upgrade data
            self.baseline_run = None
            table = run
        self.main_run = BuildStockQuery(workgroup=workgroup,
                                        db_name=db_name,
                                        buildstock_type=buildstock_type,
                                        table_name=table,
                                        skip_reports=skip_init)
        self.yaml_path = yaml_path
        self.opt_sat_path = opt_sat_path
        if not skip_init:
            self.initialize()

    def initialize(self):
        self.ua = self.main_run.get_upgrades_analyzer(self.yaml_path, self.opt_sat_path)
        self.report = pl.from_pandas(self.main_run.report.get_success_report(), include_index=True)
        self.available_upgrades = list(sorted(set(self.report[&#34;upgrade&#34;].unique()) - {0}))
        self.upgrade2name = {indx+1: f&#34;Upgrade {indx+1}: {upgrade[&#39;upgrade_name&#39;]}&#34; for indx,
                             upgrade in enumerate(self.ua.get_cfg().get(&#39;upgrades&#39;, []))}
        self.upgrade2name[0] = &#34;Upgrade 0: Baseline&#34;
        self.upgrade2shortname = {indx+1: f&#34;Upgrade {indx+1}&#34; for indx,
                                  upgrade in enumerate(self.ua.get_cfg().get(&#39;upgrades&#39;, []))}
        self.chng2bldg = self.get_change2bldgs()
        self.init_annual_results()
        self.init_monthly_results(self.metadata_df)
        self.all_upgrade_plotting_df = None

    def run_obj(self, upgrade: int) -&gt; BuildStockQuery:
        if upgrade == 0 and self.baseline_run is not None:
            return self.baseline_run
        return self.main_run

    def get_change2bldgs(self):
        change_types = [&#34;any&#34;, &#34;no-chng&#34;, &#34;bad-chng&#34;, &#34;ok-chng&#34;, &#34;true-bad-chng&#34;, &#34;true-ok-chng&#34;]
        chng2bldg = {}
        for chng in change_types:
            for upgrade in self.available_upgrades:
                print(f&#34;Getting buildings for {upgrade} and {chng}&#34;)
                chng2bldg[(upgrade, chng)] = self.main_run.report.get_buildings_by_change(upgrade_id=int(upgrade),
                                                                                          change_type=chng)
        return chng2bldg

    def _get_results_csv_clean(self, upgrade: int):
        if upgrade == 0:
            res_df = pl.read_parquet(self.run_obj(upgrade)._download_results_csv())
        else:
            res_df = pl.read_parquet(self.run_obj(upgrade)._download_upgrades_csv(upgrade_id=upgrade))
        res_df = res_df.filter(pl.col(&#39;completed_status&#39;) == &#39;success&#39;)
        res_df = res_df.drop([col for col in res_df.columns if
                              &#34;applicable&#34; in col
                              or &#34;output_format&#34; in col])
        res_df = res_df.rename({&#39;upgrade_costs.upgrade_cost_usd&#39;: &#39;upgrade_cost_total_usd&#39;})
        res_df = res_df.rename({x: x.split(&#39;.&#39;)[1] for x in res_df.columns if &#39;.&#39; in x})
        res_df = res_df.with_columns(upgrade=pl.lit(upgrade))
        res_df = res_df.with_columns(month=pl.lit(&#39;All&#39;))
        self.run_obj(upgrade).save_cache()
        return res_df

    def _get_metadata_df(self):
        bs_res_df = pl.read_parquet(self.run_obj(0)._download_results_csv())
        metadata_cols = [c for c in bs_res_df.columns if c.startswith(self.char_prefix)]
        metadata_df = bs_res_df.select([&#39;building_id&#39;] + metadata_cols)
        metadata_df = metadata_df.rename({x: x.split(&#39;.&#39;)[1] for x in metadata_df.columns if &#39;.&#39; in x})
        return metadata_df

    def init_annual_results(self):
        self.bs_res_df = self._get_results_csv_clean(0)
        self.metadata_df = self._get_metadata_df()
        self.sample_weight = self.metadata_df[&#39;sample_weight&#39;][0]
        self.upgrade2res = {0: self.bs_res_df}
        for upgrade in self.available_upgrades:
            print(f&#34;Getting up_csv for {upgrade}&#34;)
            up_csv = self._get_results_csv_clean(upgrade)
            up_csv = up_csv.join(self.metadata_df, on=&#39;building_id&#39;)
            self.upgrade2res[upgrade] = up_csv

    def _get_ts_enduse_cols(self, upgrade):
        rub_obj = self.run_obj(upgrade)
        assert rub_obj.ts_table is not None, &#34;No timeseries table found&#34;
        all_cols = [str(col.name) for col in rub_obj.get_cols(table=rub_obj.ts_table)]
        enduse_cols = filter(lambda x: x.endswith((&#39;_kbtu&#39;, &#39;_kwh&#39;, &#39;lb&#39;)), all_cols)
        return list(enduse_cols)

    def init_monthly_results(self, metadata_df):
        self.upgrade2res_monthly: dict[int, pl.DataFrame] = {}
        for upgrade in [0] + self.available_upgrades:
            ts_cols = self._get_ts_enduse_cols(upgrade)
            print(f&#34;Getting monthly results for {upgrade} for {ts_cols}&#34;)
            run_obj = self.run_obj(upgrade)
            query_string = run_obj.agg.aggregate_timeseries(enduses=ts_cols,
                                                            group_by=[run_obj.bs_bldgid_column],
                                                            upgrade_id=upgrade,
                                                            timestamp_grouping_func=&#39;month&#39;,
                                                            get_query_only=True)
            print(query_string)
            monthly_vals = run_obj.execute(query_string)
            run_obj.save_cache()
            monthly_df = pl.from_pandas(monthly_vals, include_index=True)
            monthly_df = monthly_df.with_columns(pl.col(&#39;time&#39;).dt.month().alias(&#34;month&#34;))
            monthly_df = monthly_df.with_columns(pl.col(&#39;month&#39;).map_dict(num2month).alias(&#34;month&#34;))
            modified_cols = []
            for col in ts_cols:
                # scale values down to per building and convert to m_btu to match with annual results
                if col.endswith(&#39;_kwh&#39;):
                    modified_cols.append((KWH2MBTU * pl.col(col) / pl.col(&#34;units_count&#34;))
                                         .alias(col.replace(&#34;kwh&#34;, &#34;m_btu&#34;).replace(&#34;__&#34;, &#34;_&#34;)))
                if col.endswith(&#34;_kbtu&#34;):
                    modified_cols.append((0.001 * pl.col(col) / pl.col(&#34;units_count&#34;))
                                         .alias(col.replace(&#34;kbtu&#34;, &#34;m_btu&#34;).replace(&#34;__&#34;, &#34;_&#34;)))
                else:
                    modified_cols.append((pl.col(col) / pl.col(&#34;units_count&#34;))
                                         .alias(col.replace(&#34;__&#34;, &#34;_&#34;)))
            monthly_df = monthly_df.select([&#39;building_id&#39;, &#39;month&#39;] + modified_cols
                                           + [pl.lit(upgrade).alias(&#34;upgrade&#34;)])
            monthly_df = monthly_df.join(metadata_df, on=&#39;building_id&#39;)
            self.upgrade2res_monthly[upgrade] = monthly_df

    def get_values(self,
                   upgrade: int,
                   params: PlotParams,
                   ) -&gt; pl.DataFrame:
        df = self.upgrade2res[upgrade] if params.resolution == &#39;annual&#39; else self.upgrade2res_monthly[upgrade]
        if params.filter_bldgs:
            df = df.filter(pl.col(&#39;building_id&#39;).is_in(set(params.filter_bldgs)))

        missing_cols = (pl.lit(0).alias(c) for c in params.enduses if c not in df.columns)
        df = df.with_columns(missing_cols)  # add missing cols as zero
        value_cols = [pl.sum_horizontal([pl.col(c).fill_null(0) for c in params.enduses]).alias(&#34;value&#34;)]
        other_cols = [&#39;building_id&#39;] + params.group_by
        if &#39;month&#39; not in params.group_by:
            other_cols += [&#39;month&#39;]
        return df.select(other_cols + value_cols)

    def get_plotting_df(self, upgrade: int,
                        params: PlotParams,):
        baseline_df = self.get_values(upgrade=0, params=params)
        baseline_df = baseline_df.select(&#34;building_id&#34;, &#34;month&#34;, pl.col(&#34;value&#34;).alias(&#34;baseline_value&#34;))
        up_df = self.get_values(upgrade=upgrade, params=params)
        if params.change_type:
            chng_upgrade = int(params.sync_upgrade) if params.sync_upgrade else int(upgrade) if upgrade else 0
            if chng_upgrade and chng_upgrade &gt; 0:
                change_bldg_list = self.chng2bldg[(chng_upgrade, params.change_type)]
            else:
                change_bldg_list = []
            change_bldg_list = set(change_bldg_list).intersection(up_df[&#39;building_id&#39;].to_list())
            up_df = up_df.filter(pl.col(&#34;building_id&#34;).is_in(change_bldg_list))
        up_df = up_df.join(baseline_df, on=(&#39;building_id&#39;, &#39;month&#39;), how=&#39;left&#39;)
        if params.savings_type == &#34;Savings&#34;:
            up_df = up_df.with_columns((pl.col(&#34;baseline_value&#34;) - pl.col(&#34;value&#34;)).alias(&#34;value&#34;))
            up_df = up_df
        elif params.savings_type == &#34;Percent Savings&#34;:
            up_df = up_df.with_columns((100 * (1 - pl.col(&#34;value&#34;) / pl.col(&#34;baseline_value&#34;))).alias(&#34;value&#34;))
            # handle case when baseline is 0
            up_df = up_df.with_columns(
                pl.when(pl.col(&#34;baseline_value&#34;) == 0)
                .then(-100)
                .otherwise(pl.col(&#34;value&#34;))
                .alias(&#34;value&#34;))
            up_df = up_df.with_columns(
                pl.when((pl.col(&#34;baseline_value&#34;) == 0) &amp; (pl.col(&#34;value&#34;).is_between(-1e-6, 1e-6)))
                .then(0)
                .otherwise(pl.col(&#34;value&#34;))
                .alias(&#34;value&#34;)
                )
        return up_df

    def get_all_cols(self, resolution: str) -&gt; list[str]:
        if resolution == &#39;annual&#39;:
            return self.bs_res_df.columns
        else:
            return self.upgrade2res_monthly[0].columns

    def get_all_end_use_cols(self, resolution: str) -&gt; list[str]:
        all_cols = self.get_all_cols(resolution=resolution)
        all_end_use_cols = filter(lambda col: col.startswith((&#34;end_use_&#34;, &#34;energy_use_&#34;, &#34;fuel_use_&#34;)), all_cols)
        return list(all_end_use_cols)

    def get_emissions_cols(self, resolution: str) -&gt; list[str]:
        all_cols = self.get_all_cols(resolution=resolution)
        all_emissions_cols = filter(lambda c: c.startswith(&#34;emissions_&#34;), all_cols)
        return list(all_emissions_cols)

    def get_cleaned_up_end_use_cols(self, resolution: str, fuel) -&gt; list[str]:
        cols = []
        all_end_use_cols = self.get_all_end_use_cols(resolution=resolution)
        sep = &#34;_&#34;
        for c in all_end_use_cols:
            if fuel in c or fuel == &#39;All&#39;:
                c = c.removeprefix(f&#34;end_use{sep}{fuel}{sep}&#34;)
                c = c.removeprefix(f&#34;fuel_use{sep}{fuel}{sep}&#34;)
                if fuel == &#39;All&#39;:
                    for f in sorted(fuels_types):
                        c = c.removeprefix(f&#34;end_use{sep}{f}{sep}&#34;)
                        c = c.removeprefix(f&#34;fuel_use{sep}{f}{sep}&#34;)
                cols.append(c)
        no_dup_cols = {c: None for c in cols}
        return list(no_dup_cols.keys())

    def get_end_use_db_cols(self, resolution, fuel, end_use):
        all_enduses = self.get_all_end_use_cols(resolution=resolution)
        if not end_use:
            return all_enduses[0]
        valid_cols = []
        sep = &#34;_&#34;
        prefix = &#34;fuel_use&#34; if end_use.startswith(&#34;total&#34;) else &#34;end_use&#34;
        if fuel == &#39;All&#39;:
            valid_cols.extend(f&#34;{prefix}{sep}{f}{sep}{end_use}&#34; for f in fuels_types
                              if f&#34;{prefix}{sep}{f}{sep}{end_use}&#34; in all_enduses)

        else:
            valid_cols.append(f&#34;{prefix}{sep}{fuel}{sep}{end_use}&#34;)
        return valid_cols

    def get_plotting_df_all_upgrades(self,
                                     params: PlotParams,
                                     ) -&gt; pl.DataFrame:
        df_list = []
        for upgrade in [0] + self.available_upgrades:
            df = self.get_plotting_df(upgrade=upgrade, params=params)
            df = df.with_columns(pl.lit(upgrade).alias(&#34;upgrade&#34;))
            df_list.append(df)
        return pl.concat(df_list).fill_null(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData"><code class="flex name class">
<span>class <span class="ident">VizData</span></span>
<span>(</span><span>yaml_path: str, opt_sat_path: str, db_name: str, run: Union[str, tuple[str, str]], workgroup: str = 'largeee', buildstock_type: str = 'resstock', skip_init: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VizData:
    @validate_arguments(config=dict(arbitrary_types_allowed=True, smart_union=True))
    def __init__(self, yaml_path: str, opt_sat_path: str,
                 db_name: str,
                 run: Union[str, tuple[str, str]],
                 workgroup: str = &#39;largeee&#39;,
                 buildstock_type: str = &#39;resstock&#39;,
                 skip_init: bool = False):
        if isinstance(run, tuple):
            # Allows for separate baseline and upgrade runs
            # In this case, run[0] is the baseline run and run[1] is the upgrade run
            self.baseline_run = BuildStockQuery(workgroup=workgroup,
                                                db_name=db_name,
                                                buildstock_type=buildstock_type,
                                                table_name=run[0],
                                                skip_reports=skip_init)
            baseline_table_name = run[0] + &#34;_baseline&#34;
            upgrade_table_name = run[1] + &#34;_upgrades&#34;
            ts_table_name = run[1] + &#34;_timeseries&#34;
            table = (baseline_table_name, ts_table_name, upgrade_table_name)
        else:
            # If only one run is specified, it is assumed to contain both baseline and upgrade data
            self.baseline_run = None
            table = run
        self.main_run = BuildStockQuery(workgroup=workgroup,
                                        db_name=db_name,
                                        buildstock_type=buildstock_type,
                                        table_name=table,
                                        skip_reports=skip_init)
        self.yaml_path = yaml_path
        self.opt_sat_path = opt_sat_path
        if not skip_init:
            self.initialize()

    def initialize(self):
        self.ua = self.main_run.get_upgrades_analyzer(self.yaml_path, self.opt_sat_path)
        self.report = pl.from_pandas(self.main_run.report.get_success_report(), include_index=True)
        self.available_upgrades = list(sorted(set(self.report[&#34;upgrade&#34;].unique()) - {0}))
        self.upgrade2name = {indx+1: f&#34;Upgrade {indx+1}: {upgrade[&#39;upgrade_name&#39;]}&#34; for indx,
                             upgrade in enumerate(self.ua.get_cfg().get(&#39;upgrades&#39;, []))}
        self.upgrade2name[0] = &#34;Upgrade 0: Baseline&#34;
        self.upgrade2shortname = {indx+1: f&#34;Upgrade {indx+1}&#34; for indx,
                                  upgrade in enumerate(self.ua.get_cfg().get(&#39;upgrades&#39;, []))}
        self.chng2bldg = self.get_change2bldgs()
        self.init_annual_results()
        self.init_monthly_results(self.metadata_df)
        self.all_upgrade_plotting_df = None

    def run_obj(self, upgrade: int) -&gt; BuildStockQuery:
        if upgrade == 0 and self.baseline_run is not None:
            return self.baseline_run
        return self.main_run

    def get_change2bldgs(self):
        change_types = [&#34;any&#34;, &#34;no-chng&#34;, &#34;bad-chng&#34;, &#34;ok-chng&#34;, &#34;true-bad-chng&#34;, &#34;true-ok-chng&#34;]
        chng2bldg = {}
        for chng in change_types:
            for upgrade in self.available_upgrades:
                print(f&#34;Getting buildings for {upgrade} and {chng}&#34;)
                chng2bldg[(upgrade, chng)] = self.main_run.report.get_buildings_by_change(upgrade_id=int(upgrade),
                                                                                          change_type=chng)
        return chng2bldg

    def _get_results_csv_clean(self, upgrade: int):
        if upgrade == 0:
            res_df = pl.read_parquet(self.run_obj(upgrade)._download_results_csv())
        else:
            res_df = pl.read_parquet(self.run_obj(upgrade)._download_upgrades_csv(upgrade_id=upgrade))
        res_df = res_df.filter(pl.col(&#39;completed_status&#39;) == &#39;success&#39;)
        res_df = res_df.drop([col for col in res_df.columns if
                              &#34;applicable&#34; in col
                              or &#34;output_format&#34; in col])
        res_df = res_df.rename({&#39;upgrade_costs.upgrade_cost_usd&#39;: &#39;upgrade_cost_total_usd&#39;})
        res_df = res_df.rename({x: x.split(&#39;.&#39;)[1] for x in res_df.columns if &#39;.&#39; in x})
        res_df = res_df.with_columns(upgrade=pl.lit(upgrade))
        res_df = res_df.with_columns(month=pl.lit(&#39;All&#39;))
        self.run_obj(upgrade).save_cache()
        return res_df

    def _get_metadata_df(self):
        bs_res_df = pl.read_parquet(self.run_obj(0)._download_results_csv())
        metadata_cols = [c for c in bs_res_df.columns if c.startswith(self.char_prefix)]
        metadata_df = bs_res_df.select([&#39;building_id&#39;] + metadata_cols)
        metadata_df = metadata_df.rename({x: x.split(&#39;.&#39;)[1] for x in metadata_df.columns if &#39;.&#39; in x})
        return metadata_df

    def init_annual_results(self):
        self.bs_res_df = self._get_results_csv_clean(0)
        self.metadata_df = self._get_metadata_df()
        self.sample_weight = self.metadata_df[&#39;sample_weight&#39;][0]
        self.upgrade2res = {0: self.bs_res_df}
        for upgrade in self.available_upgrades:
            print(f&#34;Getting up_csv for {upgrade}&#34;)
            up_csv = self._get_results_csv_clean(upgrade)
            up_csv = up_csv.join(self.metadata_df, on=&#39;building_id&#39;)
            self.upgrade2res[upgrade] = up_csv

    def _get_ts_enduse_cols(self, upgrade):
        rub_obj = self.run_obj(upgrade)
        assert rub_obj.ts_table is not None, &#34;No timeseries table found&#34;
        all_cols = [str(col.name) for col in rub_obj.get_cols(table=rub_obj.ts_table)]
        enduse_cols = filter(lambda x: x.endswith((&#39;_kbtu&#39;, &#39;_kwh&#39;, &#39;lb&#39;)), all_cols)
        return list(enduse_cols)

    def init_monthly_results(self, metadata_df):
        self.upgrade2res_monthly: dict[int, pl.DataFrame] = {}
        for upgrade in [0] + self.available_upgrades:
            ts_cols = self._get_ts_enduse_cols(upgrade)
            print(f&#34;Getting monthly results for {upgrade} for {ts_cols}&#34;)
            run_obj = self.run_obj(upgrade)
            query_string = run_obj.agg.aggregate_timeseries(enduses=ts_cols,
                                                            group_by=[run_obj.bs_bldgid_column],
                                                            upgrade_id=upgrade,
                                                            timestamp_grouping_func=&#39;month&#39;,
                                                            get_query_only=True)
            print(query_string)
            monthly_vals = run_obj.execute(query_string)
            run_obj.save_cache()
            monthly_df = pl.from_pandas(monthly_vals, include_index=True)
            monthly_df = monthly_df.with_columns(pl.col(&#39;time&#39;).dt.month().alias(&#34;month&#34;))
            monthly_df = monthly_df.with_columns(pl.col(&#39;month&#39;).map_dict(num2month).alias(&#34;month&#34;))
            modified_cols = []
            for col in ts_cols:
                # scale values down to per building and convert to m_btu to match with annual results
                if col.endswith(&#39;_kwh&#39;):
                    modified_cols.append((KWH2MBTU * pl.col(col) / pl.col(&#34;units_count&#34;))
                                         .alias(col.replace(&#34;kwh&#34;, &#34;m_btu&#34;).replace(&#34;__&#34;, &#34;_&#34;)))
                if col.endswith(&#34;_kbtu&#34;):
                    modified_cols.append((0.001 * pl.col(col) / pl.col(&#34;units_count&#34;))
                                         .alias(col.replace(&#34;kbtu&#34;, &#34;m_btu&#34;).replace(&#34;__&#34;, &#34;_&#34;)))
                else:
                    modified_cols.append((pl.col(col) / pl.col(&#34;units_count&#34;))
                                         .alias(col.replace(&#34;__&#34;, &#34;_&#34;)))
            monthly_df = monthly_df.select([&#39;building_id&#39;, &#39;month&#39;] + modified_cols
                                           + [pl.lit(upgrade).alias(&#34;upgrade&#34;)])
            monthly_df = monthly_df.join(metadata_df, on=&#39;building_id&#39;)
            self.upgrade2res_monthly[upgrade] = monthly_df

    def get_values(self,
                   upgrade: int,
                   params: PlotParams,
                   ) -&gt; pl.DataFrame:
        df = self.upgrade2res[upgrade] if params.resolution == &#39;annual&#39; else self.upgrade2res_monthly[upgrade]
        if params.filter_bldgs:
            df = df.filter(pl.col(&#39;building_id&#39;).is_in(set(params.filter_bldgs)))

        missing_cols = (pl.lit(0).alias(c) for c in params.enduses if c not in df.columns)
        df = df.with_columns(missing_cols)  # add missing cols as zero
        value_cols = [pl.sum_horizontal([pl.col(c).fill_null(0) for c in params.enduses]).alias(&#34;value&#34;)]
        other_cols = [&#39;building_id&#39;] + params.group_by
        if &#39;month&#39; not in params.group_by:
            other_cols += [&#39;month&#39;]
        return df.select(other_cols + value_cols)

    def get_plotting_df(self, upgrade: int,
                        params: PlotParams,):
        baseline_df = self.get_values(upgrade=0, params=params)
        baseline_df = baseline_df.select(&#34;building_id&#34;, &#34;month&#34;, pl.col(&#34;value&#34;).alias(&#34;baseline_value&#34;))
        up_df = self.get_values(upgrade=upgrade, params=params)
        if params.change_type:
            chng_upgrade = int(params.sync_upgrade) if params.sync_upgrade else int(upgrade) if upgrade else 0
            if chng_upgrade and chng_upgrade &gt; 0:
                change_bldg_list = self.chng2bldg[(chng_upgrade, params.change_type)]
            else:
                change_bldg_list = []
            change_bldg_list = set(change_bldg_list).intersection(up_df[&#39;building_id&#39;].to_list())
            up_df = up_df.filter(pl.col(&#34;building_id&#34;).is_in(change_bldg_list))
        up_df = up_df.join(baseline_df, on=(&#39;building_id&#39;, &#39;month&#39;), how=&#39;left&#39;)
        if params.savings_type == &#34;Savings&#34;:
            up_df = up_df.with_columns((pl.col(&#34;baseline_value&#34;) - pl.col(&#34;value&#34;)).alias(&#34;value&#34;))
            up_df = up_df
        elif params.savings_type == &#34;Percent Savings&#34;:
            up_df = up_df.with_columns((100 * (1 - pl.col(&#34;value&#34;) / pl.col(&#34;baseline_value&#34;))).alias(&#34;value&#34;))
            # handle case when baseline is 0
            up_df = up_df.with_columns(
                pl.when(pl.col(&#34;baseline_value&#34;) == 0)
                .then(-100)
                .otherwise(pl.col(&#34;value&#34;))
                .alias(&#34;value&#34;))
            up_df = up_df.with_columns(
                pl.when((pl.col(&#34;baseline_value&#34;) == 0) &amp; (pl.col(&#34;value&#34;).is_between(-1e-6, 1e-6)))
                .then(0)
                .otherwise(pl.col(&#34;value&#34;))
                .alias(&#34;value&#34;)
                )
        return up_df

    def get_all_cols(self, resolution: str) -&gt; list[str]:
        if resolution == &#39;annual&#39;:
            return self.bs_res_df.columns
        else:
            return self.upgrade2res_monthly[0].columns

    def get_all_end_use_cols(self, resolution: str) -&gt; list[str]:
        all_cols = self.get_all_cols(resolution=resolution)
        all_end_use_cols = filter(lambda col: col.startswith((&#34;end_use_&#34;, &#34;energy_use_&#34;, &#34;fuel_use_&#34;)), all_cols)
        return list(all_end_use_cols)

    def get_emissions_cols(self, resolution: str) -&gt; list[str]:
        all_cols = self.get_all_cols(resolution=resolution)
        all_emissions_cols = filter(lambda c: c.startswith(&#34;emissions_&#34;), all_cols)
        return list(all_emissions_cols)

    def get_cleaned_up_end_use_cols(self, resolution: str, fuel) -&gt; list[str]:
        cols = []
        all_end_use_cols = self.get_all_end_use_cols(resolution=resolution)
        sep = &#34;_&#34;
        for c in all_end_use_cols:
            if fuel in c or fuel == &#39;All&#39;:
                c = c.removeprefix(f&#34;end_use{sep}{fuel}{sep}&#34;)
                c = c.removeprefix(f&#34;fuel_use{sep}{fuel}{sep}&#34;)
                if fuel == &#39;All&#39;:
                    for f in sorted(fuels_types):
                        c = c.removeprefix(f&#34;end_use{sep}{f}{sep}&#34;)
                        c = c.removeprefix(f&#34;fuel_use{sep}{f}{sep}&#34;)
                cols.append(c)
        no_dup_cols = {c: None for c in cols}
        return list(no_dup_cols.keys())

    def get_end_use_db_cols(self, resolution, fuel, end_use):
        all_enduses = self.get_all_end_use_cols(resolution=resolution)
        if not end_use:
            return all_enduses[0]
        valid_cols = []
        sep = &#34;_&#34;
        prefix = &#34;fuel_use&#34; if end_use.startswith(&#34;total&#34;) else &#34;end_use&#34;
        if fuel == &#39;All&#39;:
            valid_cols.extend(f&#34;{prefix}{sep}{f}{sep}{end_use}&#34; for f in fuels_types
                              if f&#34;{prefix}{sep}{f}{sep}{end_use}&#34; in all_enduses)

        else:
            valid_cols.append(f&#34;{prefix}{sep}{fuel}{sep}{end_use}&#34;)
        return valid_cols

    def get_plotting_df_all_upgrades(self,
                                     params: PlotParams,
                                     ) -&gt; pl.DataFrame:
        df_list = []
        for upgrade in [0] + self.available_upgrades:
            df = self.get_plotting_df(upgrade=upgrade, params=params)
            df = df.with_columns(pl.lit(upgrade).alias(&#34;upgrade&#34;))
            df_list.append(df)
        return pl.concat(df_list).fill_null(0)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_all_cols"><code class="name flex">
<span>def <span class="ident">get_all_cols</span></span>(<span>self, resolution: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_cols(self, resolution: str) -&gt; list[str]:
    if resolution == &#39;annual&#39;:
        return self.bs_res_df.columns
    else:
        return self.upgrade2res_monthly[0].columns</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_all_end_use_cols"><code class="name flex">
<span>def <span class="ident">get_all_end_use_cols</span></span>(<span>self, resolution: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_end_use_cols(self, resolution: str) -&gt; list[str]:
    all_cols = self.get_all_cols(resolution=resolution)
    all_end_use_cols = filter(lambda col: col.startswith((&#34;end_use_&#34;, &#34;energy_use_&#34;, &#34;fuel_use_&#34;)), all_cols)
    return list(all_end_use_cols)</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_change2bldgs"><code class="name flex">
<span>def <span class="ident">get_change2bldgs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_change2bldgs(self):
    change_types = [&#34;any&#34;, &#34;no-chng&#34;, &#34;bad-chng&#34;, &#34;ok-chng&#34;, &#34;true-bad-chng&#34;, &#34;true-ok-chng&#34;]
    chng2bldg = {}
    for chng in change_types:
        for upgrade in self.available_upgrades:
            print(f&#34;Getting buildings for {upgrade} and {chng}&#34;)
            chng2bldg[(upgrade, chng)] = self.main_run.report.get_buildings_by_change(upgrade_id=int(upgrade),
                                                                                      change_type=chng)
    return chng2bldg</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_cleaned_up_end_use_cols"><code class="name flex">
<span>def <span class="ident">get_cleaned_up_end_use_cols</span></span>(<span>self, resolution: str, fuel) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cleaned_up_end_use_cols(self, resolution: str, fuel) -&gt; list[str]:
    cols = []
    all_end_use_cols = self.get_all_end_use_cols(resolution=resolution)
    sep = &#34;_&#34;
    for c in all_end_use_cols:
        if fuel in c or fuel == &#39;All&#39;:
            c = c.removeprefix(f&#34;end_use{sep}{fuel}{sep}&#34;)
            c = c.removeprefix(f&#34;fuel_use{sep}{fuel}{sep}&#34;)
            if fuel == &#39;All&#39;:
                for f in sorted(fuels_types):
                    c = c.removeprefix(f&#34;end_use{sep}{f}{sep}&#34;)
                    c = c.removeprefix(f&#34;fuel_use{sep}{f}{sep}&#34;)
            cols.append(c)
    no_dup_cols = {c: None for c in cols}
    return list(no_dup_cols.keys())</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_emissions_cols"><code class="name flex">
<span>def <span class="ident">get_emissions_cols</span></span>(<span>self, resolution: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_emissions_cols(self, resolution: str) -&gt; list[str]:
    all_cols = self.get_all_cols(resolution=resolution)
    all_emissions_cols = filter(lambda c: c.startswith(&#34;emissions_&#34;), all_cols)
    return list(all_emissions_cols)</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_end_use_db_cols"><code class="name flex">
<span>def <span class="ident">get_end_use_db_cols</span></span>(<span>self, resolution, fuel, end_use)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_use_db_cols(self, resolution, fuel, end_use):
    all_enduses = self.get_all_end_use_cols(resolution=resolution)
    if not end_use:
        return all_enduses[0]
    valid_cols = []
    sep = &#34;_&#34;
    prefix = &#34;fuel_use&#34; if end_use.startswith(&#34;total&#34;) else &#34;end_use&#34;
    if fuel == &#39;All&#39;:
        valid_cols.extend(f&#34;{prefix}{sep}{f}{sep}{end_use}&#34; for f in fuels_types
                          if f&#34;{prefix}{sep}{f}{sep}{end_use}&#34; in all_enduses)

    else:
        valid_cols.append(f&#34;{prefix}{sep}{fuel}{sep}{end_use}&#34;)
    return valid_cols</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_plotting_df"><code class="name flex">
<span>def <span class="ident">get_plotting_df</span></span>(<span>self, upgrade: int, params: <a title="buildstock_query.tools.upgrades_visualizer.plot_utils.PlotParams" href="../upgrades_visualizer/plot_utils.html#buildstock_query.tools.upgrades_visualizer.plot_utils.PlotParams">PlotParams</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plotting_df(self, upgrade: int,
                    params: PlotParams,):
    baseline_df = self.get_values(upgrade=0, params=params)
    baseline_df = baseline_df.select(&#34;building_id&#34;, &#34;month&#34;, pl.col(&#34;value&#34;).alias(&#34;baseline_value&#34;))
    up_df = self.get_values(upgrade=upgrade, params=params)
    if params.change_type:
        chng_upgrade = int(params.sync_upgrade) if params.sync_upgrade else int(upgrade) if upgrade else 0
        if chng_upgrade and chng_upgrade &gt; 0:
            change_bldg_list = self.chng2bldg[(chng_upgrade, params.change_type)]
        else:
            change_bldg_list = []
        change_bldg_list = set(change_bldg_list).intersection(up_df[&#39;building_id&#39;].to_list())
        up_df = up_df.filter(pl.col(&#34;building_id&#34;).is_in(change_bldg_list))
    up_df = up_df.join(baseline_df, on=(&#39;building_id&#39;, &#39;month&#39;), how=&#39;left&#39;)
    if params.savings_type == &#34;Savings&#34;:
        up_df = up_df.with_columns((pl.col(&#34;baseline_value&#34;) - pl.col(&#34;value&#34;)).alias(&#34;value&#34;))
        up_df = up_df
    elif params.savings_type == &#34;Percent Savings&#34;:
        up_df = up_df.with_columns((100 * (1 - pl.col(&#34;value&#34;) / pl.col(&#34;baseline_value&#34;))).alias(&#34;value&#34;))
        # handle case when baseline is 0
        up_df = up_df.with_columns(
            pl.when(pl.col(&#34;baseline_value&#34;) == 0)
            .then(-100)
            .otherwise(pl.col(&#34;value&#34;))
            .alias(&#34;value&#34;))
        up_df = up_df.with_columns(
            pl.when((pl.col(&#34;baseline_value&#34;) == 0) &amp; (pl.col(&#34;value&#34;).is_between(-1e-6, 1e-6)))
            .then(0)
            .otherwise(pl.col(&#34;value&#34;))
            .alias(&#34;value&#34;)
            )
    return up_df</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_plotting_df_all_upgrades"><code class="name flex">
<span>def <span class="ident">get_plotting_df_all_upgrades</span></span>(<span>self, params: <a title="buildstock_query.tools.upgrades_visualizer.plot_utils.PlotParams" href="../upgrades_visualizer/plot_utils.html#buildstock_query.tools.upgrades_visualizer.plot_utils.PlotParams">PlotParams</a>) ‑> polars.dataframe.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plotting_df_all_upgrades(self,
                                 params: PlotParams,
                                 ) -&gt; pl.DataFrame:
    df_list = []
    for upgrade in [0] + self.available_upgrades:
        df = self.get_plotting_df(upgrade=upgrade, params=params)
        df = df.with_columns(pl.lit(upgrade).alias(&#34;upgrade&#34;))
        df_list.append(df)
    return pl.concat(df_list).fill_null(0)</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_values"><code class="name flex">
<span>def <span class="ident">get_values</span></span>(<span>self, upgrade: int, params: <a title="buildstock_query.tools.upgrades_visualizer.plot_utils.PlotParams" href="../upgrades_visualizer/plot_utils.html#buildstock_query.tools.upgrades_visualizer.plot_utils.PlotParams">PlotParams</a>) ‑> polars.dataframe.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_values(self,
               upgrade: int,
               params: PlotParams,
               ) -&gt; pl.DataFrame:
    df = self.upgrade2res[upgrade] if params.resolution == &#39;annual&#39; else self.upgrade2res_monthly[upgrade]
    if params.filter_bldgs:
        df = df.filter(pl.col(&#39;building_id&#39;).is_in(set(params.filter_bldgs)))

    missing_cols = (pl.lit(0).alias(c) for c in params.enduses if c not in df.columns)
    df = df.with_columns(missing_cols)  # add missing cols as zero
    value_cols = [pl.sum_horizontal([pl.col(c).fill_null(0) for c in params.enduses]).alias(&#34;value&#34;)]
    other_cols = [&#39;building_id&#39;] + params.group_by
    if &#39;month&#39; not in params.group_by:
        other_cols += [&#39;month&#39;]
    return df.select(other_cols + value_cols)</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.init_annual_results"><code class="name flex">
<span>def <span class="ident">init_annual_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_annual_results(self):
    self.bs_res_df = self._get_results_csv_clean(0)
    self.metadata_df = self._get_metadata_df()
    self.sample_weight = self.metadata_df[&#39;sample_weight&#39;][0]
    self.upgrade2res = {0: self.bs_res_df}
    for upgrade in self.available_upgrades:
        print(f&#34;Getting up_csv for {upgrade}&#34;)
        up_csv = self._get_results_csv_clean(upgrade)
        up_csv = up_csv.join(self.metadata_df, on=&#39;building_id&#39;)
        self.upgrade2res[upgrade] = up_csv</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.init_monthly_results"><code class="name flex">
<span>def <span class="ident">init_monthly_results</span></span>(<span>self, metadata_df)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_monthly_results(self, metadata_df):
    self.upgrade2res_monthly: dict[int, pl.DataFrame] = {}
    for upgrade in [0] + self.available_upgrades:
        ts_cols = self._get_ts_enduse_cols(upgrade)
        print(f&#34;Getting monthly results for {upgrade} for {ts_cols}&#34;)
        run_obj = self.run_obj(upgrade)
        query_string = run_obj.agg.aggregate_timeseries(enduses=ts_cols,
                                                        group_by=[run_obj.bs_bldgid_column],
                                                        upgrade_id=upgrade,
                                                        timestamp_grouping_func=&#39;month&#39;,
                                                        get_query_only=True)
        print(query_string)
        monthly_vals = run_obj.execute(query_string)
        run_obj.save_cache()
        monthly_df = pl.from_pandas(monthly_vals, include_index=True)
        monthly_df = monthly_df.with_columns(pl.col(&#39;time&#39;).dt.month().alias(&#34;month&#34;))
        monthly_df = monthly_df.with_columns(pl.col(&#39;month&#39;).map_dict(num2month).alias(&#34;month&#34;))
        modified_cols = []
        for col in ts_cols:
            # scale values down to per building and convert to m_btu to match with annual results
            if col.endswith(&#39;_kwh&#39;):
                modified_cols.append((KWH2MBTU * pl.col(col) / pl.col(&#34;units_count&#34;))
                                     .alias(col.replace(&#34;kwh&#34;, &#34;m_btu&#34;).replace(&#34;__&#34;, &#34;_&#34;)))
            if col.endswith(&#34;_kbtu&#34;):
                modified_cols.append((0.001 * pl.col(col) / pl.col(&#34;units_count&#34;))
                                     .alias(col.replace(&#34;kbtu&#34;, &#34;m_btu&#34;).replace(&#34;__&#34;, &#34;_&#34;)))
            else:
                modified_cols.append((pl.col(col) / pl.col(&#34;units_count&#34;))
                                     .alias(col.replace(&#34;__&#34;, &#34;_&#34;)))
        monthly_df = monthly_df.select([&#39;building_id&#39;, &#39;month&#39;] + modified_cols
                                       + [pl.lit(upgrade).alias(&#34;upgrade&#34;)])
        monthly_df = monthly_df.join(metadata_df, on=&#39;building_id&#39;)
        self.upgrade2res_monthly[upgrade] = monthly_df</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    self.ua = self.main_run.get_upgrades_analyzer(self.yaml_path, self.opt_sat_path)
    self.report = pl.from_pandas(self.main_run.report.get_success_report(), include_index=True)
    self.available_upgrades = list(sorted(set(self.report[&#34;upgrade&#34;].unique()) - {0}))
    self.upgrade2name = {indx+1: f&#34;Upgrade {indx+1}: {upgrade[&#39;upgrade_name&#39;]}&#34; for indx,
                         upgrade in enumerate(self.ua.get_cfg().get(&#39;upgrades&#39;, []))}
    self.upgrade2name[0] = &#34;Upgrade 0: Baseline&#34;
    self.upgrade2shortname = {indx+1: f&#34;Upgrade {indx+1}&#34; for indx,
                              upgrade in enumerate(self.ua.get_cfg().get(&#39;upgrades&#39;, []))}
    self.chng2bldg = self.get_change2bldgs()
    self.init_annual_results()
    self.init_monthly_results(self.metadata_df)
    self.all_upgrade_plotting_df = None</code></pre>
</details>
</dd>
<dt id="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.run_obj"><code class="name flex">
<span>def <span class="ident">run_obj</span></span>(<span>self, upgrade: int) ‑> <a title="buildstock_query.main.BuildStockQuery" href="../../main.html#buildstock_query.main.BuildStockQuery">BuildStockQuery</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_obj(self, upgrade: int) -&gt; BuildStockQuery:
    if upgrade == 0 and self.baseline_run is not None:
        return self.baseline_run
    return self.main_run</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="buildstock_query.tools.characteristics_visualizer" href="index.html">buildstock_query.tools.characteristics_visualizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData">VizData</a></code></h4>
<ul class="">
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_all_cols" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_all_cols">get_all_cols</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_all_end_use_cols" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_all_end_use_cols">get_all_end_use_cols</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_change2bldgs" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_change2bldgs">get_change2bldgs</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_cleaned_up_end_use_cols" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_cleaned_up_end_use_cols">get_cleaned_up_end_use_cols</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_emissions_cols" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_emissions_cols">get_emissions_cols</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_end_use_db_cols" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_end_use_db_cols">get_end_use_db_cols</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_plotting_df" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_plotting_df">get_plotting_df</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_plotting_df_all_upgrades" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_plotting_df_all_upgrades">get_plotting_df_all_upgrades</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_values" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.get_values">get_values</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.init_annual_results" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.init_annual_results">init_annual_results</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.init_monthly_results" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.init_monthly_results">init_monthly_results</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.initialize" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.initialize">initialize</a></code></li>
<li><code><a title="buildstock_query.tools.characteristics_visualizer.viz_data.VizData.run_obj" href="#buildstock_query.tools.characteristics_visualizer.viz_data.VizData.run_obj">run_obj</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>